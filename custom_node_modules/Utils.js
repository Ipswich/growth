var moment = require('moment')
var pug = require('pug')
const path = require('path')

//Formats DB time  for human friendly reading (used for Schedule)
module.exports.formatTimeString = function formatTimeString(input){
  return moment(input, 'HH:mm:ss').format("h:mm A")
}

//Formats date string for DB entry
module.exports.formatDateString = function formatDateString(input){
  if (input == 'NULL'){
    return input;
  }
  //Remove first and last character
  input = input.substring(1, input.length-1);
  var string = "";
  //Split input on '/'
  var destructed = input.split("/");
  //Reassemble destructed parts
  string = "'" + destructed[2] + "-" + destructed[0] + "-" + destructed[1] + "'"
  return string;
}

//Formats time string for DB entry.
module.exports.formatTimeStringForDB = function formatTimeStringH(input){
  return moment(input, 'h:mm A').format("HH:mm:ss");
}

//Formats DB date to human friendly reading (used for current conditions)
module.exports.dateFormat = function(input) {
  return moment(input).format("MMMM D, h:mm:ss A");
}

module.exports.getSensorVal = async function getSensorVal(state, i) {
  let obj = state.sensorState.getSensorObject(i);
  let units = state.sensorState.getSensorUnits(i);
  let data = {}
  data.sensorID = state.sensorState.getSensorID(i);
  if(obj != undefined) {
    return new Promise((resolve) => {
      obj.once('data', () => {
        switch (state.sensorState.getSensorType(i)) {
          case 'Temperature':
            if (units == "°C" || units == "C") {
              data.val = obj.C;
            } else if (units == "°F" || units == "F") {
              data.val = obj.F;
            }
            break;
          case 'Humidity':
            data.val = obj.RH;
            break;
          case 'Pressure':
            data.val = obj.pressure;
            break;
          case 'CarbonDioxide':
            data.val = -1;
            break;
          default:
            data.val = -1;
        }
        resolve(data);
      })
    });
  }
}

module.exports.getIndexData = async function getIndexData(req, con){

  return new Promise((resolve) => {
    var web_data = req.app.get('web_data');
    var errorPacket = {err: "Database error! Website not updated."}
    //Redo old pages
    //setup paths
    const schedules = path.join(req.app.get('views'), '/schedules.pug');
    const currentConditions = path.join(req.app.get('views'), '/currentConditions.pug');
    //Create pug render functions
    var cSchedules = pug.compileFile(schedules);
    var cCurrentConditions = pug.compileFile(currentConditions);

    //grab Index Page Data
    //Get last readings from sensors
    con.query('CALL getSensorLastReadings()', (error, results, fields) => {
      if(error){
        //Error on problem.
        con.destroy();
        resolve(errorPacket);
      } else {
        var sensorData = {sensorData: results[0]};
        for (var key in sensorData.sensorData){
          //Format logtime to be human readable
          sensorData.sensorData[key].logTime = module.exports.dateFormat(sensorData.sensorData[key].logTime);
        }
        //Get enabled sensor types
        con.query('CALL getEnabledSensorTypes()', (error, results, fields) => {
          if(error){
            //Error on problem.
            con.destroy();
            resolve(errorPacket);
          } else {
            var sensorTypes = {sensorTypes: results[0]};
            //Get enabled live schedules
            con.query('CALL getEnabledLiveSchedules()', (error, results, fields) => {
              if(error){
                //Error on problem.
                con.destroy();
                resolve(errorPacket);
              } else {
                var scheduleData = {scheduleData: results[0]};
                //Format trigger Time to be human readable
                for (var key in scheduleData.scheduleData){
                  scheduleData.scheduleData[key].eventTriggerTime = module.exports.formatTimeString(scheduleData.scheduleData[key].eventTriggerTime);
                }
                //Get enabled outputs
                con.query('CALL getEnabledOutputs()', (error, results, fields) => {
                  if(error){
                    //Error on problem.
                    con.destroy();
                    resolve(errorPacket);
                  } else {
                    var outputs = {outputs: results[0]};
                    //Get enabled events
                    con.query('CALL getEnabledEvents()', (error, results, fields) => {
                      if(error){
                        //Error on problem.
                        con.destroy();
                        resolve(errorPacket);
                      } else {
                        var events = {events: results[0]};
                        //Get enabled sensors
                        con.query('CALL getEnabledSensors()', (error, results, fields) => {
                          if(error){
                            //Error on problem.
                            con.destroy();
                            resolve(errorPacket);
                          } else {
                            var sensors = {sensors: results[0]};
                            //Create data object for rendering html
                            var data = Object.assign({}, web_data, sensorTypes, sensorData, scheduleData, outputs, events, sensors);
                            con.destroy();
                            //Render and add to object
                            var schedulesPug = {schedules: cSchedules(data)};
                            var currentConditionsPug = {currentConditions: cCurrentConditions(data)};
                            //Create packet, send.
                            var packet = Object.assign({}, schedulesPug, currentConditionsPug, data);
                            resolve(packet);
                          }
                        })
                      }
                    })
                  }
                })
              }
            })
          }
        })
      }
    })
  })
}
