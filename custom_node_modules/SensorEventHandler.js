var mysql = require('mysql');
var config = require('../config/config.json');
var moment = require('moment');
var mappings = require('./Mappings.js')

if(process.env.NODE_ENV == 'development'){
  config = config.development;
} else {
  config = config.production;
}

//Runs sensor events based on last readings from DB
module.exports.SensorEventHandler = async function SensorEventHandler(outputState){
  const events = await getEvents();
  const sensorReadings = await getSensorReadings();
  const outputs = await mappings.getOutputMappings();
  const schedule = await getSchedule();
  if (events == undefined || outputs == undefined || schedule == undefined) {
    console.error("SensorEventHandler.js: SensorEventHandler() failed!");
  } else {
    //Iterate through schedules
    for(let i = 0; i < schedule.length; i++) {
      //Find the last sensor reading for the schedule's sensor
      for(let j = 0; j < sensorReadings.length; j++) {
        if(schedule[i].sensorID == sensorReadings[j].sensorID){
          var sensorVal = sensorReadings[j].data;
        }
      }
      //Switch based on schedule's comparator
      switch(schedule[i].scheduleComparator) {
      case '>':
        if(sensorVal > schedule[i].sensorValue) {
          triggerEvent(schedule[i], outputs, outputState);
        }
        break;
      case '<':
        if(sensorVal < schedule[i].sensorValue) {
          triggerEvent(schedule[i], outputs, outputState);
        }
        break;
      }
    }
  }
}

//Gets last conditions
function getSensorReadings() {
  return new Promise(resolve => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err){
        reject(err);
      } else {
        con.query('CALL getSensorLastReadings()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("SensorEventHandler.js: getSensorReadings() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve(results[0])
          }
        })
      }
    });
  })
}

//Gets enabled sensor events from DB
function getEvents() {
  return new Promise(resolve => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err){
        reject(err);
      } else {
        con.query('CALL getEnabledEvents()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("SensorEventHandler.js: getEvents() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve(results[0])
          }
        })
      }
    });
  })
}

//Gets the current live and enabled schedule from DB
function getSchedule() {
  return new Promise(resolve => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err){
        reject(err);
      } else {
        con.query('CALL getEnabledLiveSchedules()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("SensorEventHandler.js: getEnabledLiveSchedules() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            var schedule = results[0].filter(filterByScheduleType)
            resolve(schedule)
          }
        })
      }
    });
  })
}

//Triggers event on hardware
function triggerEvent(schedule, outputs, outputState) {
  //Iterate through output mappings
  for(let i = 0; i < outputs.length; i++) {
    //if current output ID matches passed schedule output ID
    if (outputs[i].outputID == schedule.outputID){
      //set output to that output
      var output = outputs[i];
    }
  }
  //Case switch based on event ID 1 = on, 2 = off
  let outputStateData = outputState.getOutputState();
  switch (schedule.eventID) {
    case 1:
      //Iterate through state - if state is already set to on, return
      for (let i = 0; i < outputStateData.length; i++){
        if ((output.outputID == outputStateData[i].outputID) && (outputStateData[i].scheduleState == 1))
          {
          return;
        }
      }
      //Otherwise, update state and log and do stuff
      console.log(output.outputName + " @ " + output.OUTPUT_PIN +  ": ON @ " + schedule.outputValue + "%, pwmPin: " + output.PWM_PIN);
      outputState.setOutputScheduleState(output.outputID, 1);
      logEvent(schedule.scheduleID);
      break;
    case 2:
      //Iterate through state - if state is already set to off, return
      for (let i = 0; i < outputState.length; i++){
        if ((output.outputID == outputStateData[i].outputID) && (outputStateData[i].scheduleState == 2)) {
          return;
        }
      }
      //Otherwise, update state and log and do stuff
      console.log(output.outputName + " @ " + output.OUTUPUT_PIN + ": OFF!");
      outputState.setOutputScheduleState(output.outputID, 2);
      logEvent(schedule.scheduleID);
      break;
  }
}

//Logs that an event occurred
function logEvent(scheduleID) {
  return new Promise(resolve => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err) {
        reject(err);
      } else {
        con.query('CALL logScheduledEvent(' + scheduleID + ')', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("SensorEventHandler.js: logEvent() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve();
          }
        })
      }
    });
  })
}

//Function for filtering out Sensor schedules from Time Schedules.
function filterByScheduleType(schedule){
  if (schedule.scheduleType == 'Sensor'){
    return true;
  }
  return false;
}
