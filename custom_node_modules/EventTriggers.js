var mysql = require('mysql');
var config = require('../config/config.json');
var moment = require('moment');
var outputState = require('./OutputState.js')

if(process.env.NODE_ENV == 'development'){
  config = config.development;
} else {
  config = config.production;
}

//Gets last conditions
module.exports.getSensorReadings = function getSensorReadings() {
  return new Promise(resolve => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err){
        reject(err);
      } else {
        con.query('CALL getSensorLastReadings()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("Triggers.js: getSensorReadings() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve(results[0])
          }
        })
      }
    });
  })
}

//Gets enabled time events from DB
module.exports.getEvents = function getEvents() {
  return new Promise((resolve, reject) => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err){
        throw err
        reject(err);
      } else {
        con.query('CALL getEnabledEvents()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("EventTriggers.js: getEvents() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve(results[0])
          }
        })
      }
    });
  })
}

//Gets the current live and enabled schedule from DB
module.exports.getSchedule = function getSchedule(type) {
  return new Promise((resolve, reject) => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err) {
        throw err
        reject(err);
      } else {
        con.query('CALL getEnabledLiveSchedules()', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("EventTriggers.js: getEnabledLiveSchedules() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            var schedule = filterByScheduleType(results[0], type);
            resolve(schedule);
          }
        })
      }
    });
  })
}

//Triggers event on hardware
module.exports.triggerEvent = function triggerEvent(schedule, state) {
  //Iterate through output mappings
  for(let i = 0; i < state.outputState.getOutputState().length; i++){
    //if current output ID matches passed schedule output ID
    if (state.outputState.getOutputState()[i].outputID == schedule.outputID){
      //set output to that output
      var output = state.outputState.getOutputState()[i];
    }
  }
  //Case switch based on event ID 1 = on, 2 = off
  let outputStateData = state.outputState.getOutputState();
  switch (schedule.eventID) {
    case 1:
      //Iterate through state
      for (let i = 0; i < outputStateData.length; i++){
        //if state is already set to on AND outputValue == scheduleOutputValue, return
        if ((output.outputID == outputStateData[i].outputID) && (outputStateData[i].scheduleState == 1) && (outputStateData[i].scheduleOutputValue == schedule.outputValue)) {
          return;
        }
      }
      //schedule ID does not exist in outputs list, add it
      if(!state.outputState.checkOutputSchedules(output.outputID, schedule.scheduleID)){
        state.outputState.addOutputSchedules(output.outputID, schedule.scheduleID);
      }

      //Otherwise, update state and log and do stuff
      console.log(output.outputName + " @ " + output.outputPin +  ": ON @ " + schedule.outputValue + "%, pwmPin: " + output.outputPWMPin);
      output.outputObject.on();
      if(output.outputPWMObject){
        let base = 255/100;
        let value = Math.round(base * schedule.outputValue);
        console.log(value)
        output.outputPWMObject.brightness(value);
      }
      state.outputState.setOutputScheduleState(output.outputID, 1, schedule.outputValue);
      logEvent(schedule.scheduleID);
      break;
    case 2:
      //Iterate through state - if state is already set to off, return
      for (let i = 0; i < state.outputState.length; i++){
        if ((output.outputID == outputStateData[i].outputID) && (outputStateData[i].scheduleState == 2)) {
          return;
        }
      }

      //schedule ID exists in outputs list, remove it
      if(!state.outputState.checkOutputSchedules(output.outputID, schedule.scheduleID)){
        state.outputState.removeOutputSchedules(output.outputID, schedule.scheduleID);
      }

      //Otherwise, update state and log and do stuff
      console.log(output.outputName + " @ " + output.OUTUPUT_PIN + ": OFF!");
      output.outputObject.off();
      state.outputState.setOutputScheduleState(output.outputID, 2, schedule.outputValue);

      logEvent(schedule.scheduleID);
      break;
  }
}

//Logs that an event occurred
function logEvent(scheduleID) {
  return new Promise((resolve, reject) => {
    var con = mysql.createConnection(config.database);
    con.connect((err) => {
      if(err) {
        throw err
        reject(err);
      } else {
        con.query('CALL logScheduledEvent(' + scheduleID + ')', (error, results, fields) => {
          //Error on problem.
          if(error) {
            console.error("EventTriggers.js: logEvent() failed, database error.");
            con.destroy();
            reject(error);
          } else {
            //DO STUFF WITH DATA
            con.destroy();
            resolve()
          }
        })
      }
    });
  })
}

//Function for filtering out type schedules from Sensor Schedules.
function filterByScheduleType(schedule, type) {
  var result = [];
  for(let i = 0; i < schedule.length; i++){
    if (schedule[i].scheduleType == type){
      result.push(schedule[i]);
    }
  }
  return result;
}

module.exports.turnOffOutput = function turnOffOutput(state, output){
  //Iterate through state - if state is already set to off, return
  for(let i = 1; i <= state.outputState.getOutputState().length; i++){
      if ((output.outputID == state.outputState.getOutputID(i)) && (state.outputState.getOutputScheduleState() == 2)) {
      return;
    }
  }
  //Otherwise, update state and log and do stuff
  console.log(output.outputName + " @ " + output.OUTUPUT_PIN + ": OFF!");
  output.outputObject.off();
  state.outputState.setOutputScheduleState(output.outputID, 2, 0);
}
