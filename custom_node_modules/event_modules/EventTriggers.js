const {spawn} = require('child_process')
const nodemailer = require('nodemailer')
const config = require('../../config/config.json')
const webdata = require('../../config/web-data-config.json')
var dbcalls = require('../utility_modules/database_calls.js')
const utils = require('../utility_modules/Utils.js')

const script_directory = process.cwd() + '/scripts/'

//Gets the current live and enabled schedule from DB
module.exports.getSchedule = async function getSchedule(type) {
  return filterByScheduleType(await dbcalls.getEnabledLiveSchedules(), type)
}

//Triggers event on hardware
module.exports.triggerEvent = async function triggerEvent(schedule, state, event = null) {
  //Iterate through output mappings to get output
  for(let i = 0; i < state.outputState.getOutputState().length; i++){
    //if current output ID matches passed schedule output ID
    if (state.outputState.getOutputState()[i].outputID == schedule.outputID){
      //set output to that output
      var output = state.outputState.getOutputState()[i];
    }
  }
  //If event is set, switch differently.
  var switchCase
  if (event != null){
    switchCase = event
  } else {
    switchCase = schedule.eventID
  }


  //Disable schedule if it's a manual one to ensure it only ever runs once
  if(schedule.scheduleType == "Manual"){
    await dbcalls.disableSchedule(schedule.scheduleID, "'SYSTEM'")
  }

  switch (switchCase) {
    case 'Output On':
      if(!filterOn(output, schedule, state)) {
        return;
      } 
      // Turn on relay
      if(output.outputPWMObject){
        // Do math for PWM object (255 bit)
        let value;
        let base = 255/100;
        //If inversion set, use 255 - PWM value
        if (output.outputPWMInversion == 0) {
          value = Math.round(base * schedule.outputValue);
        } else {
          value = 255 - Math.round(base * schedule.outputValue);
        }
        output.outputPWMObject.brightness(value);        
        output.outputObject.close();
        utils.debugPrintout(output.outputName + ": [" + output.outputController + "] ON @ " + schedule.outputValue + "% - [Output Pin: " + output.outputPin + ", PWM Pin: " + output.outputPWMPin + "]");      
      } else {
        utils.debugPrintout(output.outputName + ": [" + output.outputController + "] ON - [Output Pin: " + output.outputPin + "]");      
        output.outputObject.close();
      }
      await dbcalls.logScheduledEvent(schedule.scheduleID);
      if(schedule.scheduleType == 'Manual'){
        state.outputState.setOutputManualState(output.outputID, "Output On", schedule.outputValue);
      } else {
        state.outputState.setOutputScheduleState(output.outputID, "Output On", schedule.outputValue);
      }
      
      break;

    case 'Output Off':
      if(!filterOff(output, schedule, state)){
        return;
      }
      //Otherwise, update state and log and do stuff
      utils.debugPrintout(output.outputName + ": [" + output.outputController + "] OFF - [Output Pin: " + output.outputPin + "]");  
      output.outputObject.open();
      await dbcalls.logScheduledEvent(schedule.scheduleID);      
      if(schedule.scheduleType == 'Manual'){
        state.outputState.setOutputManualState(output.outputID, "Output Off", schedule.outputValue);
      } else {
        state.outputState.setOutputScheduleState(output.outputID, "Output Off", schedule.outputValue);
      }
      break;

    case 'Email Warn' :
      // If server says config isn't set up, pass
      if(state.warnState == false){
        break;
      }
      // If no email, send no email
      if(schedule.email == null || schedule.email == undefined){
        break;
      }
      const transporter = nodemailer.createTransport(config.nodemailer)
      // Create message based on scheduleType
      let msg = ''
      switch (schedule.scheduleType) {
        case 'Time':
          msg = "Time warning: " + utils.formatTimeString(schedule.eventTriggerTime)
          break;
        case 'Sensor':
          let comparator = (schedule.scheduleComparator == '<') ? ' is less than ' : ' is greater than '
          msg = "Sensor warning: " + schedule.sensorType + " @ " + schedule.sensorLocation + comparator + schedule.sensorValue + schedule.sensorUnits + "."
          break;
      }
      // Pull data from config files
      const mailOptions = {
        from: config.nodemailer.auth.user,
        to: schedule.email,
        subject: "Warning from " + webdata.title,
        text: msg
      }
      // SEND THE MAIL! And log event.
      transporter.sendMail(mailOptions, async function(error, info) {
        if(error) {
          utils.debugPrintout("Error sending mail: " + error)
        } else {
          utils.debugPrintout("Warning sent to " + schedule.email + ".")      
          await dbcalls.logScheduledEvent(schedule.scheduleID);
        }
      })
      break;
    case 'Python Script':
      let file = schedule.parameter1;
      let input_file = [];
      input_file.push(script_directory + file)
      let python = spawn('python', input_file);
      python.stdout.on('data', function (data) {
        utils.debugPrintout("Running python script: " + file)        
        pythonOutput = data.toString();
      });
      python.on('close', (code) => {
        console.log(pythonOutput)
        utils.debugPrintout(file + " exited, code: " + code)
      });       
      await dbcalls.logScheduledEvent(schedule.scheduleID);
      break;
  }
}

//Gracefully turns off and updates state for the given output
module.exports.turnOffOutput = function turnOffOutput(state, output){
  // if state is already set to off, return
  if (output.scheduleState == 'Output Off') {
    return;
  }
  //Otherwise, update state and log and do stuff
  utils.debugPrintout(output.outputName + ": [" + output.outputController + "] OFF - [Output Pin: " + output.outputPin + "]");  
  output.outputObject.open();
  state.outputState.setOutputScheduleState(output.outputID, "Output Off", 0);
}

module.exports.resumeSchedule = function resumeSchedule(outputState, outputID){
  let output = outputState.getOutput(outputID)
  if (output.scheduleState == 'Output On') {
    //If no state change, return
    if(output.manualState == output.scheduleState && output.manualOutputValue == output.scheduleOutputValue){
      return
    }
    if(output.outputPWMObject){
      // Do math for PWM object (255 bit)
      let value;
      let base = 255/100;
      //If inversion set, use 255 - PWM value
      if (output.outputPWMInversion == 0) {
        value = Math.round(base * output.scheduleOutputValue);
      } else {
        value = 255 - Math.round(base * output.scheduleOutputValue);
      }
      output.outputPWMObject.brightness(value);
    }
    if(output.outputPWMPin != null) {
      utils.debugPrintout(output.outputName + ": [" + output.outputController + "] ON @ " + output.scheduleOutputValue + "% - [Output Pin: " + output.outputPin + ", PWM Pin: " + output.outputPWMPin + "]");      
    } else {
      utils.debugPrintout(output.outputName + ": [" + output.outputController + "] ON - [Output Pin: " + output.outputPin + "]");      
    }
    output.outputObject.close()
  } else {
    //If no state change, return
    if(output.manualState == output.scheduleState){
      return
    }
    utils.debugPrintout(output.outputName + ": [" + output.outputController + "] OFF - [Output Pin: " + output.outputPin + "]");    
    output.outputObject.open()    
  }    
  outputState.setLastOutputController(outputID, outputState.getOutputController(outputID))
}


//Function for filtering out type schedules from Sensor Schedules.
function filterByScheduleType(schedule, type) {
  var result = [];
  for(let i = 0; i < schedule.length; i++){
    if (schedule[i].scheduleType == type){
      result.push(schedule[i]);
    }
  }
  return result;
}

function filterOn(output, schedule, state) {
  if(output.outputController == "Manual"){
    //if last state was set to on output value hasn't changed, return  
    if(schedule.scheduleType != "Manual"){
      //If output controller is manual but schedule type is not, update schedule state
      state.outputState.setOutputScheduleState(output.outputID, "Output On", schedule.outputValue);
      // console.log("[Manual] ON @ " + schedule.outputValue + " - SKIPPED, SCHEDULE IN MANUAL STATE")
      return false;
    }
    if(output.lastOutputController == 'Schedule' && output.scheduleState == "Output On"){
      //Change of controller - update last output controller, state
      state.outputState.setLastOutputController(output.outputID, state.outputState.getOutputController(output.outputID))          
      if(output.outputPWMObject){
        if(output.scheduleOutputValue == schedule.outputValue) {
          state.outputState.setOutputManualState(output.outputID, "Output On", schedule.outputValue);
          // console.log("[Manual] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
          return false;
        }
      } else {
        state.outputState.setOutputManualState(output.outputID, "Output On", schedule.outputValue);
        // console.log("[Manual] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
        return false;
      }
    }
    if(output.lastOutputController == 'Manual' && output.manualState == "Output On") {
      if(output.outputPWMObject){
        if(output.manualOutputValue == schedule.outputValue) {          
          // console.log("[Manual] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
          return false;
        }
      } else {
        // console.log("[Manual] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
        return false;
      }
    } 
  } else {
    //OutputController == Schedule
    //If output controller is NOT manual and schedule type is manual, return
    if(schedule.scheduleType == "Manual"){
      state.outputState.setOutputManualState(output.outputID, "Output On", schedule.outputValue);
      // console.log("[Schedule] ON @ " + schedule.outputValue + " - SKIPPED, MANUAL IN SCHEDULE STATE")
      return false;
    }
    if(output.lastOutputController == 'Schedule' && output.scheduleState == "Output On") {
      if(output.outputPWMObject){
        if(output.scheduleOutputValue == schedule.outputValue) {          
          // console.log("[Schedule] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
          return false;
        }
      } else {
        // console.log("[Schedule] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
        return false;
      }
    }
    if(output.lastOutputController == 'Manual' && output.manualState == "Output On") {
      //Change of controller - update last output controller, state
      state.outputState.setLastOutputController(output.outputID, state.outputState.getOutputController(output.outputID))
      if(output.outputPWMObject){
        if(output.manualOutputValue == schedule.outputValue) {              
          state.outputState.setOutputScheduleState(output.outputID, "Output On", schedule.outputValue);
          // console.log("[Schedule] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
          return false;
        }
      } else {
        state.outputState.setOutputScheduleState(output.outputID, "Output On", schedule.outputValue);
        // console.log("[Schedule] ON @ " + schedule.outputValue + " - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
        return false;
      }
    }   
  }   
  return true;         
}

function filterOff(output, schedule, state) {
  if(output.outputController == "Manual"){
    if(schedule.scheduleType != "Manual"){          
      // If output controller is manual, and schedule type is NOT manual, return
      state.outputState.setOutputScheduleState(output.outputID, "Output Off");
      // console.log("[Manual] OFF - SKIPPED, SCHEDULE IN MANUAL STATE")
      return false;
    } 
    //if old state was set to off, return        
    if(output.lastOutputController == 'Schedule' && output.scheduleState == "Output Off") {
      state.outputState.setOutputManualState(output.outputID, "Output Off");
      // console.log("[Manual] OFF - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
      return false;
    }
    if(output.lastOutputController == 'Manual' && output.manualState == "Output Off"){
      // console.log("[Manual] OFF - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
      return false;
    }        
  } else {
    //Output controller == Schedule
    // If output controller is NOT manual, and schedule type is manual, return
    if(schedule.scheduleType == "Manual"){          
      state.outputState.setOutputManualState(output.outputID, "Output Off");
      // console.log("[Schedule] OFF - SKIPPED, MANUAL IN SCHEDULE STATE")
      return false;
    }
    //if old state was set to off, return        
    if(output.lastOutputController == 'Schedule' && output.scheduleState == "Output Off") {
      // console.log("[Schedule] OFF - SKIPPED, SAME AS PREVIOUS SCHEDULE STATE")
      return false;
    }
    if(output.lastOutputController == 'Manual' && output.manualState == "Output Off"){
      state.outputState.setOutputScheduleState(output.outputID, "Output Off");
      // console.log("[Schedule] OFF - SKIPPED, SAME AS PREVIOUS MANUAL STATE")
      return false;
    } 
  }
  return true;
}