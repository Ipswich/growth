const moment = require('moment')
const dbcalls = require('../../utility_modules/database_calls.js')
const eventTriggers = require('../EventTriggers.js')
const utils = require('../../utility_modules/Utils.js')

// Clear triggered schedules every minute
var triggeredSchedules = []

//Runs sensor events based on last readings from DB
module.exports.SensorEventHandler = async function SensorEventHandler(state){
  const events = await dbcalls.getEnabledEvents();
  var schedule = await eventTriggers.getSchedule('Sensor');
  schedule = utils.eventTypeMapper(events, schedule)
  var sensorData = [];
  for(let i = 0; i < state.sensorState.getSensorState().length; i++){
    sensorData[i] = await utils.getSensorVal(state, i);
  }
  if (events == undefined || schedule == undefined) {
    console.error("SensorEventHandler.js: SensorEventHandler() failed!");
  } else {
    //Iterate through schedules
    for(let i = 0; i < schedule.length; i++) { 
      var present = false
      for(let j = 0; j < triggeredSchedules.length; j++ ){
        // If the triggered schedule is present, update marker.  
        if(schedule[i].scheduleID == triggeredSchedules[j].scheduleID){
          present = true
        }
        // If triggered schedule has the same minute as now, remove the schedule.
        if(moment().isSame(triggeredSchedules[j].timeout, 'minute')){
          triggeredSchedules.splice(j, 1)          
        }
      };
      if (present == true){        
        continue
      }
      //Find the last sensor reading for the schedule's sensor
      for(let j = 1; j <= sensorData.length; j++) {
        if(sensorData[j] && schedule[i].sensorID == sensorData[j].sensorID) {
          var sensorVal = sensorData[j].val;
        }
      }
      //Switch based on schedule's comparator AND if schedule has not been triggered yet.
      switch(schedule[i].scheduleComparator) {
        case '>':
          if(sensorVal > schedule[i].sensorValue) {
            eventTriggers.triggerEvent(schedule[i], state);
            // Add to array of triggered schedule
            let timeout;
            if(schedule[i].eventName == 'Warn'){
              timeout = moment().add(schedule[i].eventInterval, 'm')
            } else {
              timeout = moment().add(1, 'm')
            }           
            let data = {
              scheduleID: schedule[i].scheduleID,
              timeout: timeout
            }
            triggeredSchedules.push(data)
          }
          break;
      case '<':
        if(sensorVal < schedule[i].sensorValue) {
          eventTriggers.triggerEvent(schedule[i], state);
            // Add to array of triggered schedule
            let timeout;
            if(schedule[i].eventName == 'Warn'){
              timeout = moment().add(schedule[i].eventInterval, 'm')
            } else {
              timeout = moment().add(1, 'm')
            }           
            let data = {
              scheduleID: schedule[i].scheduleID,
              timeout: timeout
            }
            triggeredSchedules.push(data)        
        }
        break;
      }
    }
  }
}
