const dbcalls = require('../../utility_modules/database_calls.js')
const eventTriggers = require('../EventTriggers.js')
const utils = require('../../utility_modules/Utils.js')

// Clear triggered schedules every minute
var triggeredSchedules = []
setInterval(()=> {
  triggeredSchedules = []
}, 1000 * 60)

//Runs sensor events based on last readings from DB
module.exports.SensorEventHandler = async function SensorEventHandler(state){
  const events = await dbcalls.getEnabledEvents();
  var schedule = await eventTriggers.getSchedule('Sensor');
  schedule = utils.eventTypeMapper(events, schedule)
  
  var sensorData = [];
  for(let i = 1; i <= state.sensorState.getSensorState().length; i++){
    sensorData[i] = await utils.getSensorVal(state, i);
  }
  if (events == undefined || schedule == undefined) {
    console.error("SensorEventHandler.js: SensorEventHandler() failed!");
  } else {
    //Iterate through schedules
    for(let i = 0; i < schedule.length; i++) {
      //Find the last sensor reading for the schedule's sensor
      for(let j = 1; j <= sensorData.length; j++) {
        if(sensorData[j] && schedule[i].sensorID == sensorData[j].sensorID) {
          var sensorVal = sensorData[j].val;
        }
      }
      //Switch based on schedule's comparator AND if schedule has not been triggered yet.
      switch(schedule[i].scheduleComparator) {
      case '>':
        if(sensorVal > schedule[i].sensorValue && !triggeredSchedules.includes(schedule[i].scheduleID)) {
          eventTriggers.triggerEvent(schedule[i], state);
          // Add to array of triggered schedule
          triggeredSchedules.push(schedule[i].scheduleID);
        }
        break;
      case '<':
        if(sensorVal < schedule[i].sensorValue && !triggeredSchedules.includes(schedule[i].scheduleID)) {
          eventTriggers.triggerEvent(schedule[i], state);
          // Add to array of triggered schedule
          triggeredSchedules.push(schedule[i].scheduleID);
          
        }
        break;
      }
    }
  }
}
