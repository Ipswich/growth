const moment = require('moment')
const dbcalls = require('../../utility_modules/database_calls.js')
const eventTriggers = require('../eventTriggers.js')
const printouts = require('../../utility_modules/printouts');
const utils = require('../../utility_modules/utils.js')
const TriggeredScheduleMinder = require('./TriggeredScheduleMinder');

// Clear triggered schedules every minute
let triggeredScheduleMinder = new TriggeredScheduleMinder()

/**
 * Runs sensor schedules based on the passed state. If a schedule's sensor value 
 * matches the sensor's current value, runs the schedule. Schedules are minded, 
 * and only run once per minute.
 * @param {object} state The current state of the system.
 */
module.exports.sensorEventHandler = async function SensorEventHandler(state){
  const events = await dbcalls.getEnabledEvents();
  let schedule = await eventTriggers.getSchedule('Sensor');
  schedule = utils.eventTypeMapper(events, schedule)
  // Get sensor data for each sensor - update last reading
  for(let i = 0; i < state.sensorState.getSensorState().length; i++){
    state.sensorState.data[i].sensorLastReading = await state.sensorState.getSensorVal(i);
  }
  if (events == undefined || schedule == undefined) {
    printouts.simpleErrorPrintout("SensorEventHandler.js: SensorEventHandler() failed!");
  } else {
    //Iterate through schedules
    for(let i = 0; i < schedule.length; i++) { 
      // If the minder includes the current schedule, skip to next schedule
      if(triggeredScheduleMinder.includes(schedule[i].scheduleID)){
        continue
      }
      let sensorVal = state.sensorState.data[i].sensorLastReading.val
      //Switch based on schedule's comparator AND if schedule has not been triggered yet.      
      switch(schedule[i].scheduleComparator) {
        case '>':
          if(sensorVal > schedule[i].sensorValue) {
            runSchedule(schedule[i], state, sensorVal)
          }
          break;
        case '<':
          if(sensorVal < schedule[i].sensorValue) { 
            runSchedule(schedule[i], state, sensorVal)
          }
          break;
      }
    }
  }
  // Clean up all schedules from minder
  triggeredScheduleMinder.auto_remove_schedules()
}

/**
 * Helper function; Runs the schedule.
 * @param {object} schedule schedule to be run
 * @param {object} state state object
 * @param {number} sensorVal value for the current schedule
 */
const runSchedule = function(schedule, state, sensorVal){
  eventTriggers.triggerEvent(schedule, state, null, sensorVal);
  // Add to array of triggered schedule; update timeout
  let timeout;
  if(schedule.eventName == 'Email Warn'){
    timeout = moment().add(schedule.eventInterval, 'm')
  } else {
    timeout = moment().add(1, 'm')
  }           
  let data = {
    scheduleID: schedule.scheduleID,
    timeout: timeout
  }
  triggeredScheduleMinder.add_schedule(data)
  return 
}
