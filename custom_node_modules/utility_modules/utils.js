const jwt = require('jsonwebtoken')
const moment = require('moment')
const dbcalls = require('./database_calls.js')
const eventTriggers = require('../event_modules/EventTriggers')
const fs = require('fs')
const config_helper = require('../utility_modules/config_helper')

//Formats DB time for human friendly reading (used for Schedule)
function formatTimeString(input) {
  return moment(input, 'HH:mm:ss').format("h:mm A")
}
module.exports.formatTimeString = formatTimeString

//Formats date string for DB entry
function formatDateStringForDB(input) {
  if (input == 'NULL'){
    return input;
  }
  //Remove first and last character
  input = input.substring(1, input.length-1);
  var string = "";
  //Split input on '/'
  var destructed = input.split("/");
  //Reassemble destructed parts
  string = "'" + destructed[2] + "-" + destructed[0] + "-" + destructed[1] + "'"
  return string;
}
module.exports.formatDateStringForDB = formatDateStringForDB

//Formats time string for DB entry.
function formatTimeStringForDB(input) {
  return moment(input, 'h:mm A').format("HH:mm:ss");
}
module.exports.formatTimeStringForDB = formatTimeStringForDB

//Formats DB date to human friendly reading (used for current conditions)
function dateFormat(input) {
  return moment(input).format("MMMM D, h:mm A");
}
module.exports.dateFormat = dateFormat

// "Minds" the schedule. Basically makes sure devices are accounted for and 
// removed from operation if no schedules for it exists.
async function scheduleMinder(state) {
  let schedules = await dbcalls.getEnabledLiveSchedules()
  for(i = 0; i < state.outputState.getOutputState().length; i++){
    let present = false
    for(j = 0; j < schedules.length; j++){
      if (state.outputState.data[i].outputID == schedules[j].outputID){
        present = true
      }
    }
    if (present != true){
      if(state.outputState.data[i].outputController != 'Manual') {
        eventTriggers.turnOffOutput(state, state.outputState.data[i])
      }
      state.outputState.setOutputScheduleState(state.outputState.data[i].outputID, "Output Off", 0);
    }
  }
}
module.exports.scheduleMinder = scheduleMinder

// Maps event name to schedule instead of eventID. eventID is an autoincrement in the DB,
// and therefore could cause problems if the eventID was referenced instead of event name.
function scheduleTypeMapper(events, schedules) {
  for (let i = 0; i < schedules.length; i++) {
    for(let j = 0; j < events.length; j++) {
      if (schedules[i].eventID == events[j].eventID){
        schedules[i].eventID = events[j].eventName
      }
    }
  }
  return schedules
}
module.exports.eventTypeMapper = scheduleTypeMapper

// Detects if there's a valid cookie.
function cookieDetector(req) {
  const config = config_helper.getConfig()
  try {
    jwt.verify(req.cookies.token, config.jwt_secret)
  } catch(e) {
    return false
  }
  return true
}
module.exports.cookieDetector = cookieDetector

function getScriptFileNames(file_type) {
  let files = fs.readdirSync('./scripts')
  let sortedFiles = files.filter(e => e.split('.').pop() == file_type);
  return sortedFiles;
}
module.exports.getScriptFileNames = getScriptFileNames