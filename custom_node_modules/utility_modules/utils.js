const fs = require('fs')
const jwt = require('jsonwebtoken')
const moment = require('moment')
const config_helper = require('../utility_modules/config_helper')
const dbcalls = require('./database_calls.js')
const eventTriggers = require('../event_modules/eventTriggers')
const printouts = require('./printouts')


/**
 * Formats a time string from the database to be more human friendly.
 * @param {string} input Time string; MUST be of the format HH:mm:ss
 * @returns {string} The formatted string, or 'invalid date' if input was not
 * properly formatted
 */
function formatTimeString(input) {
  let result = moment(input, 'HH:mm:ss').format("h:mm A");
  if(result == 'Invalid date') {
    printouts.simpleErrorPrintout("formatTimeString() - Invalid date")
  }
  return result
}
module.exports.formatTimeString = formatTimeString

/**
 * Formats a date string from the database to be more human friendly.
 * @param {string} input Date string; Must be of the format YYYY/MM/DD HH:mm:ss
 * @returns {string} the formatted string, or 'invalid date' if input was not
 * properly formatted
 */
function formatDateString(input) {
  let result = moment(input).format("MMMM D, h:mm A");
  if(result == 'Invalid date') {
    printouts.simpleErrorPrintout("formatDateString() - Invalid date")
  }
  return result
}
module.exports.formatDateString = formatDateString

/**
 * Formats a human entered time string for the database.
 * @param {string} input Time string; MUST be of the format h:mm A
 * @returns {string} the formatted string, or 'invalid date' if input was not
 * properly formatted
 */
function formatTimeStringForDB(input) {
  let result = moment(input, 'h:mm A').format("HH:mm:ss");
  if(result == 'Invalid date') {
    printouts.simpleErrorPrintout("formatTimeStringForDB() - Invalid date")
  }
  return result
}
module.exports.formatTimeStringForDB = formatTimeStringForDB

/**
 * Formats a human entered date string for the database.
 * @param {string} input Date string; MUST be of the format MM/DD/YYYY
 * @returns {string} the formatted string, or 'invalid date' if input was not
 * properly formatted
 */
function formatDateStringForDB(input) {
  if (input == 'NULL'){
    return input;
  }
  //Remove first and last character
  input = input.substring(1, input.length-1);
  var string = "";
  //Split input on '/'
  var destructed = input.split("/");
  if (
    destructed[0].toString().length != 2 ||
    destructed[1].toString().length != 2 ||
    destructed[2].toString().length != 4) {
    return 'Invalid date'
  }
  //Reassemble destructed parts
  string = "'" + destructed[2] + "-" + destructed[0] + "-" + destructed[1] + "'"
  return string;
}
module.exports.formatDateStringForDB = formatDateStringForDB

/**
 * "Minds" the schedule. Ensures that outputs are turned off if there are no
 * schedules that reference them. Manually controlled outputs are untouched,
 * but outputScheduleState is updated if needed.
 * @param {object} state the curent state
 */
async function scheduleMinder(state) {
  let schedules = await dbcalls.getEnabledLiveSchedules()
  let outputs = state.outputState.getOutputState()
  for(i = 0; i < outputs.length; i++){
    let present = false
    for(j = 0; j < schedules.length; j++){
      if (outputs[i].outputID == schedules[j].outputID){
        present = true
      }
    }
    if (present != true){
      if(outputs[i].outputController != 'Manual') {
        eventTriggers.turnOffOutput(state, outputs[i])
      }
      state.outputState.setOutputScheduleState(outputs[i].outputID, "Output Off", 0);
    }
  }
}
module.exports.scheduleMinder = scheduleMinder

/**
 * Maps event names to schedules, replacing eventID with a string if possible.
 * @param {array} events array of events
 * @param {array} schedules array of schedules
 * @returns schedules; modifies schedules in place.
 */
function eventTypeMapper(events, schedules) {
  for (let i = 0; i < schedules.length; i++) {
    for(let j = 0; j < events.length; j++) {
      if (schedules[i].eventID == events[j].eventID){
        schedules[i].eventID = events[j].eventName
      }
    }
  }
  return schedules
}
module.exports.eventTypeMapper = eventTypeMapper

/**
 * Checks a request to see if the attached cookie contains a valid JWT token.
 * @param {object} req express html request
 * @returns true if token is valid, false othrwise.
 */
function cookieDetector(req) {
  const config = config_helper.getConfig()
  try {
    jwt.verify(req.cookies.token, config.jwt_secret)
  } catch(e) {
    return false
  }
  return true
}
module.exports.cookieDetector = cookieDetector

/**
 * Gets an array of files in the SCRIPT_DIRECTORY file that match 
 * @param {string} file_type file type ending
 * @returns {array} array of files that match the passed file type
 */
function getScriptFileNames(file_type) {
  let config = config_helper.getConfig()
  let files = fs.readdirSync(config.script_directory)
  let sortedFiles = files.filter(e => e.split('.').pop() == file_type);
  return sortedFiles;
}
module.exports.getScriptFileNames = getScriptFileNames