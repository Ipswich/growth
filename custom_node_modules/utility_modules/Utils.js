const jwt = require('jsonwebtoken')
var moment = require('moment')
var pug = require('pug')
const path = require('path')
const board_mappings = require('../../config/board_mappings.json')
const config = require('../../config/config.json')
const dbcalls = require('./database_calls.js')
const eventTriggers = require('../event_modules/EventTriggers')

const CHART_INTERVAL = 24
const INTERVALS = {
  0:{
    interval: 6,
    title: "6 Hours",
    default: false
  },
  1:{
    interval: 12,
    title: "12 Hours",
    default: false
  },
  2:{
    interval: 24,
    title: "1 Day",
    default: true
  },
  3:{
    interval: 48,
    title: "2 Days",
    default: false
  },
  4:{
    interval: 72,
    title: "3 Days",
    default: false
  },
  5:{
    interval: 168,
    title: "1 Week",
    default: false
  },
}
var board = null;

module.exports.getBoardMapping = function getBoardMapping(){
  if(board == null) {
    board = board_mappings[config.board]  
  }
  return board
}

//Formats DB time for human friendly reading (used for Schedule)
module.exports.formatTimeString = function formatTimeString(input){
  return moment(input, 'HH:mm:ss').format("h:mm A")
}

//Formats date string for DB entry
module.exports.formatDateString = function formatDateString(input){
  if (input == 'NULL'){
    return input;
  }
  //Remove first and last character
  input = input.substring(1, input.length-1);
  var string = "";
  //Split input on '/'
  var destructed = input.split("/");
  //Reassemble destructed parts
  string = "'" + destructed[2] + "-" + destructed[0] + "-" + destructed[1] + "'"
  return string;
}

//Formats time string for DB entry.
module.exports.formatTimeStringForDB = function formatTimeStringH(input){
  return moment(input, 'h:mm A').format("HH:mm:ss");
}

//Formats DB date to human friendly reading (used for current conditions)
module.exports.dateFormat = function(input) {
  return moment(input).format("MMMM D, h:mm A");
}

//Formats chart date for friendly reading.
module.exports.chartDateFormat = function(input) {
  return moment(input.format)
}

// Gets value from a specific sensor.
module.exports.getSensorVal = async function getSensorVal(state, i) {
  let obj = state.sensorState.getSensorObject(i);
  let units = state.sensorState.getSensorUnits(i);
  let data = {}
  data.sensorID = state.sensorState.getSensorID(i);
  if(obj != undefined) {
    return new Promise((resolve) => {
      obj.once('data', () => {
        switch (state.sensorState.getSensorType(i)) {
          case 'Temperature':
            if (units == "°C" || units == "C") {
              data.val = obj.C;
            } else if (units == "°F" || units == "F") {
              data.val = obj.F;
            }
            break;
          case 'Humidity':
            data.val = obj.RH;
            break;
          case 'Pressure':
            data.val = obj.pressure;
            break;
          case 'CarbonDioxide':
            data.val = -1;
            break;
          default:
            data.val = -1;
        }
        resolve(data);
      })
    });
  }
}

// Generates HTML data from Pug templates for both current conditions and schedule.
module.exports.getIndexData = async function getIndexData(res, req, interval = CHART_INTERVAL){
  return new Promise(async (resolve, reject) => {
    var web_data = req.app.get('web_data');
    //Redo old pages
    //setup paths
    const schedules = path.join(req.app.get('views'), '/schedules.pug');
    const currentConditions = path.join(req.app.get('views'), '/currentConditions.pug');
    const addEvent = path.join(req.app.get('views'), '/addEvent.pug');
    const manual = path.join(req.app.get('views'), '/manual.pug');
    //Create pug render functions
    var cSchedules = pug.compileFile(schedules);
    var cCurrentConditions = pug.compileFile(currentConditions);
    var cAddEvent = pug.compileFile(addEvent);
    var cManual = pug.compileFile(manual);
    
    //grab Index Page Data
    try {
      //Get last readings from sensors
      let sensorData = {sensorData: await dbcalls.getSensorLastReadings()}
      let sensorLast12 = await dbcalls.getSensorLastReadingsByHours(interval)
      for (var key in sensorData.sensorData){
        //Format logtime to be human readable
        sensorData.sensorData[key].logTime = module.exports.dateFormat(sensorData.sensorData[key].logTime);
      }
      //Format data for charts
      sensorData.last12 = []
      for (var key in sensorLast12){
        if(sensorData.last12[sensorLast12[key].sensorID] == undefined){
          sensorData.last12[sensorLast12[key].sensorID] = []
        }
        let dataPair = {}
        dataPair.x = sensorLast12[key].logTime
        dataPair.y = sensorLast12[key].data
        sensorData.last12[sensorLast12[key].sensorID].push(dataPair)
      }
      var sensorTypes = {sensorTypes: await dbcalls.getEnabledSensorTypes()};
      var scheduleData = {scheduleData: await dbcalls.getEnabledLiveSchedules()};
      //Format trigger Time to be human readable
      for (var key in scheduleData.scheduleData){
        scheduleData.scheduleData[key].eventTriggerTime = module.exports.formatTimeString(scheduleData.scheduleData[key].eventTriggerTime);
      }
      //Get enabled outputs
      var outputs = {outputs: await dbcalls.getEnabledOutputs()};
      //Get enabled events
      var events = {events: await dbcalls.getEnabledEvents()};
      //Get enabled sensors
      var sensors = {sensors: await dbcalls.getEnabledSensors()};
      //Create data object for rendering html
      var intervals = {intervals: INTERVALS}      
      //Get outputs from state
      let state = {state: req.app.get('state').outputState.data}
      if (res.locals.authenticated || cookieDetector(req)){
        var authenticated = {authenticated: true }
      } else {
        var authenticated = {authenticated: false }
      }
      var data = Object.assign({}, web_data, sensorTypes, sensorData, sensorLast12, scheduleData, outputs, events, sensors, intervals, state, authenticated);
      //Render and add to object
      var manualPug = {manual: cManual(data)};
      var addEventPug = {addEvent: cAddEvent(data)};
      var schedulesPug = {schedules: cSchedules(data)};
      var currentConditionsPug = {currentConditions: cCurrentConditions(data)};
      //Create packet, resolve.
      var packet = Object.assign({}, schedulesPug, currentConditionsPug, addEventPug, manualPug, data);
      resolve(packet);
    } catch (e) {
      //If error, error
      reject(e);
    }
    
  })
}

// Renders the 'schedules.pug' as HTML and returns the data.
module.exports.getSchedulesHTML = async function getSchedulesHTML(res, req){
  return new Promise(async (resolve, reject) => {
    var web_data = req.app.get('web_data');
    const schedules = path.join(req.app.get('views'), '/schedules.pug');
    var cSchedules = pug.compileFile(schedules);
    try {
      var scheduleData = {scheduleData: await dbcalls.getEnabledLiveSchedules()};
      //Format trigger Time to be human readable
      for (var key in scheduleData.scheduleData){
        scheduleData.scheduleData[key].eventTriggerTime = module.exports.formatTimeString(scheduleData.scheduleData[key].eventTriggerTime);
      }
      if (res.locals.authenticated || cookieDetector(req)){
        var authenticated = {authenticated: true }
      } else {
        var authenticated = {authenticated: false }
      }
      var data = Object.assign({}, web_data, scheduleData, authenticated);
      var schedulesPug = {schedules: cSchedules(data)};
      resolve(schedulesPug);
    } catch (e) {
      //If error, error
      reject(e);
    }
  })
}


// Renders the 'addEvents.pug' as HTML and returns the data.
module.exports.getAddEventHTML = async function getAddEventHTML(res, req) {
  return new Promise(async (resolve, reject) => {
    var web_data = req.app.get('web_data');
    const addEvent = path.join(req.app.get('views'), '/addEvent.pug');
    var cAddEvent = pug.compileFile(addEvent);
    try {
      //Get enabled outputs
      var outputs = {outputs: await dbcalls.getEnabledOutputs()};
      //Get enabled events
      var events = {events: await dbcalls.getEnabledEvents()};
      //Get enabled sensors
      var sensors = {sensors: await dbcalls.getEnabledSensors()};
      if (res.locals.authenticated || cookieDetector(req)){
        var authenticated = {authenticated: true }
      } else {
        var authenticated = {authenticated: false }
      }
      var data = Object.assign({}, web_data, outputs, events, sensors, authenticated);
      var addEventPug = {addEvent: cAddEvent(data)};
      resolve(addEventPug);
    } catch (e) {
      //If error, error
      reject(e);
    }
  })
}

module.exports.getManualHTML = async function getManualHTML(res, req) {
  return new Promise(async (resolve, reject) => {
    var web_data = req.app.get('web_data');
    const manual = path.join(req.app.get('views'), '/manual.pug');
    var cManual = pug.compileFile(manual);
    try {
      //Get outputs from state
      let state = {state: req.app.get('state').outputState.data}
      if (res.locals.authenticated || cookieDetector(req)){
        var authenticated = {authenticated: true }
      } else {
        var authenticated = {authenticated: false }
      }
      var data = Object.assign({}, web_data, state, authenticated);
      var manualPug = {manual: cManual(data)};
      resolve(manualPug);
    } catch (e) {
      //If error, error
      reject(e);
    }
  })
}

// "Minds" the schedule. Basically makes sure devices are accounted for and removed
// from operation if no schedules for it exists.
module.exports.scheduleMinder = async function scheduleMinder(state){
  let schedules = await dbcalls.getEnabledLiveSchedules()
  for(i = 0; i < state.outputState.getOutputState().length; i++){
    let present = false
    for(j = 0; j < schedules.length; j++){
      if (state.outputState.data[i].outputID == schedules[j].outputID){
        present = true
      }
    }
    if (present != true){
      if(state.outputState.data[i].outputController != 'Manual') {
        eventTriggers.turnOffOutput(state, state.outputState.data[i])
      }
      state.outputState.setOutputScheduleState(state.outputState.data[i].outputID, "Output Off", 0);
    }
  }

}

// Maps event name to schedule instead of eventID. eventID is an autoincrement in the DB,
// and therefore could cause problems if the eventID was referenced instead of event name.
module.exports.eventTypeMapper = function scheduleTypeMapper(events, schedules){
  for (let i = 0; i < schedules.length; i++) {
    for(let j = 0; j < events.length; j++) {
      if (schedules[i].eventID == events[j].eventID){
        schedules[i].eventID = events[j].eventName
      }
    }
  }
  return schedules
}

// Detects if there's a valid cookie.
function cookieDetector(req) {
  try {
    jwt.verify(req.cookies.token, config.jwt_secret)
  } catch(e) {
    return false
  }
  return true
}
module.exports.cookieDetector = cookieDetector