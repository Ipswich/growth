var fs = require('fs');
var path = require("path");
var mysql = require('mysql');
if(process.env.NODE_ENV == 'test'){
  var config = require('../../config/test-config.json');
  if(process.env.DB_PORT){
    config.database.port = proces.env.DB_PORT
  }
} else {  
  var config = require('../../config/config.json');
}

console.log(config.database)
// Create connection pool
var pool = mysql.createPool(config.database)
// Check connection
if (!checkConnectivity()){
  process.exit(-1)
}

async function checkConnectivity() {
  pool.query('SELECT 1 + 1 AS solution', function (error, results, fields) {
    if (error) {
      console.log(error)
      console.error("ERROR: Database could not be reached.\n")
      return false
    };
    console.log("Database successfully connected");
    return true
  });
}
module.exports.checkConnectivity = checkConnectivity


module.exports.addNewEvent = async function(name, description, enabled) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewEvent(' + name + ',' + description + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewEvent() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewOutput = async function(type, name, description, order = 0) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewOutput(' + type + ',' + name + ',' + description + ',' + order + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewOutput() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewOutputType = async function(type, pwm, pwm_inversion, enabled) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewOutputType(' + type + ',' + pwm + ',' + pwm_inversion + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewOutputType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewSchedule = async function(scheduleType, eventID, sensorID, sensorValue, outputID, outputValue, scheduleComparator, eventTriggerTime, eventDuration, eventInterval, scheduleStartDate, scheduleStopDate, enabled, addedBy, disabledBy, parameter1) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSchedule(' + scheduleType + ',' + eventID + ',' + sensorID + ',' + sensorValue + ',' + outputID + ',' + outputValue + ',' + scheduleComparator + ',' + eventTriggerTime + ',' + eventDuration + ',' + eventInterval + ',' + scheduleStartDate + ',' + scheduleStopDate + ',' + enabled + ',' + addedBy + ',' + disabledBy + ',' + parameter1 + ')'    
    pool.query(query, (error, results, fields) => {
      //Error on problem
      console
      if(error) {
        console.error("addNewSchedule() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewScheduleType = async function(type, enabled) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewScheduleType(' + type + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewScheduleType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewSensor = async function(model, type, location, units, hardwareID, sensorProtocol, sensorAddress = 'NULL') {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSensor(' + model + ',' + type + ',' + location + ',' + units + ',' + hardwareID + ',' + sensorProtocol + ',' + sensorAddress + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewSensor() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewSensorType = async function(type, enabled) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSensorType(' + type + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewSensorType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addNewUser = async function(username, hash, email) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewUser(' + username + ',"' + hash + '",' + email + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addNewUser() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.addSensorReading = async function(sensorID, data) {
  return new Promise((resolve, reject) => {
    let query = 'CALL addSensorReading(' + sensorID + ',' + data + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("addSensorReading() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.disableSchedule = async function(id, user) {
  return new Promise((resolve, reject) => {
    let query = 'CALL disableSchedule(' + id + ',' + user + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("disableSchedule() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.disableOutputType = async function(id) {
  return new Promise((resolve, reject) => {
    let query = 'CALL disableOutputType(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("disableOutputType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.disableOutput = async function(id) {
  return new Promise((resolve, reject) => {
    let query = 'CALL disableOutput(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("disableOutput() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.disableSensor = async function(id) {
  return new Promise((resolve, reject) => {
    let query = 'CALL disableSensor(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("disableSensor() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllEvents = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllEvents()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllEvents() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllOutputs = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllOutputs() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllOutputTypes = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllOutputTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllOutputTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllSchedules = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllSchedules() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllScheduleTypes = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllScheduleTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllScheduleTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllSensors = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSensors()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllSensors() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllSensorTypes = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSensorTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllSensorTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getAllUsers = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllUsers()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getAllUsers() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledEvents = async function() {
  return new Promise((resolve, reject) => {
    let query = 'CALL getEnabledEvents()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledEvents() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledLiveSchedules = async function(){
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledLiveSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledLiveSchedules() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledOutputs = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledOutputs() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledOrderedOutputs = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledOrderedOutputs() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledOutputTypes = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledOutputTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledSchedules = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledSchedules() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledScheduleTypes = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledScheduleTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledScheduleTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledSensors = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSensors()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledSensors() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getEnabledSensorTypes = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSensorTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getEnabledSensorTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getScheduleByID = async function(id) {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getScheduleByID(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getScheduleByID() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getSensorDataByType = async function(type) {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorDataByType(' + type + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getSensorDataByType() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getSensorLastReadings = async function() {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorLastReadings()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getSensorLastReadings() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getSensorLastReadingsByHours = async function(hours) {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorLastReadingsByHours(' + hours + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getSensorLastReadingsByHours() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.getUser = async function(username) {
  return new Promise((resolve, reject) => {    
    let query = 'CALL getUser(' + username + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("getUser() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.logScheduledEvent = async function(scheduleID) {
  return new Promise((resolve, reject) => {    
    let query = 'CALL logScheduledEvent(' + scheduleID + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        console.error("logScheduledEvent() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

module.exports.updateSensorAddress = async function(address, sensorID){
  return new Promise(resolve => {
    let query = 'CALL updateSensorAddress(' + address + ', ' + sensorID + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        console.error("updateSensorAddress() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.updateOutputType = async function(id, type, pwm, pwm_inversion){
  return new Promise(resolve => {
    let query = 'CALL updateOutputType(' + id + ', ' + type + ',' + pwm + ',' + pwm_inversion + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        console.error("updateOutputType() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.updateOutput = async function(id, type, name, description, order){
  return new Promise(resolve => {
    let query = 'CALL updateOutput(' + id + ', ' + type + ',' + name + ',' + description + ',' + order + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        console.error("updateOutput() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.updateSensor = async function(id, model, type, location, units, hardwareID, protocol, address){
  return new Promise(resolve => {
    let query = 'CALL updateSensor(' + id + ', ' + model + ',' + type + ',' + location + ',' + units + ',' + hardwareID + ',' + protocol + ',' + address + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        console.error("updateSensor() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

module.exports.createTestDBStructure = async function(){
  return new Promise(resolve => {
    let query = fs.readFileSync('./SQL/schema_testDB.sql').toString()
    // console.log(query)
    fs.writeFileSync('./query.log', query)
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        console.log(error.sqlMessage)
        console.error("createDBStructure() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}


