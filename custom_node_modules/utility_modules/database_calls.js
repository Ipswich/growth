var mysql = require('mysql');
var config_helper = require('./config_helper');
const {simpleLogPrintout, simpleErrorPrintout} = require('./printouts')

const config = config_helper.getConfig()

var pool
/**
 * Singleton; Creates and returns a mysql connection pool, 
 * or returns a previously created one.
 * @returns mysql connection pool.
 */
const getPool = async function() {
  if (pool) return pool
  pool = mysql.createPool(config.database)
  return pool
}
module.exports.getPool = getPool

/**
 * Tests if the database pool and connection are functional.
 * @returns {Promise<[object]>} A promise that resolves with results of a simple query to test 
 * connectivity. 
 */
const testConnectivity = async function(){
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    pool.query('SELECT 1 + 1 AS solution', (error, results) => {
      if (error) {
        simpleErrorPrintout(error)
        simpleErrorPrintout("ERROR: Database could not be reached.\n")
        reject(error)
      } else {
        simpleLogPrintout("Database successfully connected"); 
        resolve(results)
      }   
    });
  })
}
module.exports.testConnectivity = testConnectivity

/**
 * Adds a new event to the database.
 * @param {string} name Name of new event.
 * @param {string} description Event description.
 * @param {number} enabled 0 for false, 1 for true; enables or disables the 
 * event.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is 
 * insert only.
 */
module.exports.addNewEvent = async function(name, description, enabled) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewEvent(' + name + ',' + description + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewEvent() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new output to the database.
 * @param {number} type Output type; must map to an existing output type.
 * @param {string} name Output name.
 * @param {string} description Description of the output. 
 * @param {number} order Ascending logical ordering of the output; higher 
 * number is lower on the list, with 0 being last. Defaults to 0.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is 
 * insert only.
 */
module.exports.addNewOutput = async function(type, name, description, order = 0) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewOutput(' + type + ',' + name + ',' + description + ',' + order + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewOutput() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new output type to the database.
 * @param {string} type Output type name.
 * @param {number} pwm 1 for PWM enabled, 0 for not.
 * @param {number} pwm_inversion 1 for inverted PWM, 0 for not. (100% low, vs 
 * 0% low).
 * @param {number} enabled 0 for false, 1 for true; enables or disables the 
 * output type. 
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only.
 */
module.exports.addNewOutputType = async function(type, pwm, pwm_inversion, enabled) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewOutputType(' + type + ',' + pwm + ',' + pwm_inversion + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewOutputType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new schedule to the database.
 * @param {string} scheduleType Name of schedule type triggered by schedule;
 * must map to an existing scheduleType.
 * @param {number} eventID ID of the event triggered by schedule; must map
 * to an existing event.
 * @param {number} sensorID ID of the sensor to read and trigger schedule.
 * @param {number} sensorValue Sensor value to be compared to the current
 * value; used to trigger schedule.
 * @param {number} outputID ID of the output triggered by schedule; must map
 * to an existing output.
 * @param {number} outputValue 0-100 representation of pwm intensity.
 * @param {string} scheduleComparator Must be '>' or '<', compares current 
 * sensor value on the left with the trigger sensorValue on the right.
 * @param {string} eventTriggerTime String representation of the start time
 * for the schedule.
 * @param {number} eventDuration Run time of the event in minutes; how long 
 * before ending.
 * @param {number} eventInterval Run time between events in minutes; how long
 * before running again.
 * @param {string} scheduleStartDate String representation of the start date
 * for the schedule.
 * @param {string} scheduleStopDate String representation of the stop date
 * for the schedule
 * @param {number} enabled 0 for false, 1 for true; enables or disables the 
 * schedule.
 * @param {string} addedBy User adding this schedule. Must map to a user in the
 * user table.
 * @param {string} disabledBy User removing this schedule. Must map to a user
 * in the user table.
 * @param {string} parameter1 Variable data used by this schedule.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addNewSchedule = async function(scheduleType, eventID, sensorID, sensorValue, outputID, outputValue, scheduleComparator, eventTriggerTime, eventDuration, eventInterval, scheduleStartDate, scheduleStopDate, enabled, addedBy, disabledBy, parameter1) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSchedule(' + scheduleType + ',' + eventID + ',' + sensorID + ',' + sensorValue + ',' + outputID + ',' + outputValue + ',' + scheduleComparator + ',' + eventTriggerTime + ',' + eventDuration + ',' + eventInterval + ',' + scheduleStartDate + ',' + scheduleStopDate + ',' + enabled + ',' + addedBy + ',' + disabledBy + ',' + parameter1 + ')'    
    pool.query(query, (error, results, fields) => {
      //Error on problem
      console
      if(error) {
        simpleErrorPrintout("addNewSchedule() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new schedule type to the database.
 * @param {string} type String name for schedule type.
 * @param {number} enabled 0 for false, 1 for true; enables or disables the 
 * schedule type. 
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addNewScheduleType = async function(type, enabled) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewScheduleType(' + type + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewScheduleType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new sensor to the database.
 * @param {string} model Model number or descriptor of sensor (i.e DS18B20,
 *  BME280).
 * @param {string} type Type of sensor; must map to an existing sensorType.
 * @param {string} location Location descriptor of sensor placement; used to
 *  identify individual sensors.
 * @param {string} units Units read by sensor; used for display purposes.
 * @param {number} hardwareID Hardware identifier used to group sensors that share
 * hardware (i.e. BME280). Each piece of hardware should have its own unique
 * hardwareID.
 * @param {string} sensorProtocol Sensor protocol for reading data (i.e. ANALOG
 * , I2C, ONEWIRE).
 * @param {string} sensorAddress Used for sensors that share a common data pin.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addNewSensor = async function(model, type, location, units, hardwareID, sensorProtocol, sensorAddress = 'NULL') {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSensor(' + model + ',' + type + ',' + location + ',' + units + ',' + hardwareID + ',' + sensorProtocol + ',' + sensorAddress + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewSensor() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new sensorType to the database.
 * @param {string} type Descriptor of sensor data type (Temperature, Humidity, etc.)
 * @param {number} enabled 0 for false, 1 for true; enables or disables the 
 * sensor type. 
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addNewSensorType = async function(type, enabled) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewSensorType(' + type + ',' + enabled + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewSensorType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a new user to the database.
 * @param {string} username User's login name.
 * @param {string} hash Password hash.
 * @param {string} email Email address of the user; used for email warnings.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addNewUser = async function(username, hash, email) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addNewUser(' + username + ',"' + hash + '",' + email + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addNewUser() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds a sensor reading to the database.
 * @param {number} sensorID sensorID that refers to the sensor read.
 * @param {number} data Data read in by the sensor indicated by sensorID.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only. 
 */
module.exports.addSensorReading = async function(sensorID, data) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL addSensorReading(' + sensorID + ',' + data + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("addSensorReading() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Disables a schedule in the database.
 * @param {number} id ID of the schedule to disable.
 * @param {string} user The user disabling this schedule.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only. 
 */
module.exports.disableSchedule = async function(id, user) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL disableSchedule(' + id + ',' + user + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("disableSchedule() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Disables an output type in the database.
 * @param {number} id Output type to disable.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only. 
 */
module.exports.disableOutputType = async function(id) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL disableOutputType(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("disableOutputType() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Disables an output in the database.
 * @param {number} id Output to disable.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only. 
 */
module.exports.disableOutput = async function(id) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL disableOutput(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("disableOutput() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Disables a sensor in the database.
 * @param {number} id Sensor to disable.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only. 
 */
module.exports.disableSensor = async function(id) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL disableSensor(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("disableSensor() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all events from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllEvents = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllEvents()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllEvents() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all outputs from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllOutputs = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllOutputs() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all output types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllOutputTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllOutputTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllOutputTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all schedules from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllSchedules = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllSchedules() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all schedule types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllScheduleTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllScheduleTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllScheduleTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all sensors from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllSensors = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSensors()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllSensors() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all sensor types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllSensorTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllSensorTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllSensorTypes() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all users from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getAllUsers = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getAllUsers()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getAllUsers() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled events from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledEvents = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {
    let query = 'CALL getEnabledEvents()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledEvents() failed, database error.");
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled and active (in date range) schedules from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledLiveSchedules = async function(){
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledLiveSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledLiveSchedules() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled outputs from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledOutputs = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledOutputs() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled outputs from the database, in ascending order with 0
 * last.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledOrderedOutputs = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputs()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledOrderedOutputs() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled output types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledOutputTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledOutputTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledOutputTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled schedules from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledSchedules = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSchedules()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledSchedules() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled schedule types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledScheduleTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledScheduleTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledScheduleTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled sensors from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledSensors = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSensors()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledSensors() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects enabled sensor types from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getEnabledSensorTypes = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getEnabledSensorTypes()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getEnabledSensorTypes() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects a schedule from the database by the passed ID.
 * @param {number} id ID of the schedule to select.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getScheduleByID = async function(id) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getScheduleByID(' + id + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getScheduleByID() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects all data from the database for sensors with the passed type.
 * @param {string} type Type of sensor data to select; must map to an
 * existing sensor Type.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getSensorDataByType = async function(type) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorDataByType(' + type + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getSensorDataByType() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}
/**
 * Selects the last reading for each sensor from the database.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getSensorLastReadings = async function() {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorLastReadings()'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getSensorLastReadings() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Selects the data from all sensors that has been recorded in the last hours.
 * @param {number} hours Passed hours to select data for.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getSensorLastReadingsByHours = async function(hours) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getSensorLastReadingsByHours(' + hours + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getSensorLastReadingsByHours() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Select the passed username from the database.
 * @param {string} username User to select for.
 * @returns {Promise<[object]>} A promise that resovles with the results of the query.
 */
module.exports.getUser = async function(username) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL getUser(' + username + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("getUser() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Adds the passed event to the log table in the database.
 * @param {number} scheduleID ID of the schedule to add to the database;
 * must map to an existing schedule.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * insert only.
 */
module.exports.logScheduledEvent = async function(scheduleID) {
  let pool = await exports.getPool()
  return new Promise((resolve, reject) => {    
    let query = 'CALL logScheduledEvent(' + scheduleID + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem
      if(error) {
        simpleErrorPrintout("logScheduledEvent() failed, database error.");
        reject(error);
      } else {
        //(success)
        resolve(results[0])
      }
    })
  })
}

/**
 * Updates a sensor address in the database.
 * @param {string} address The new address.
 * @param {number} sensorID The sensor to update; must map to an existing
 * sensor.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only.
 */
module.exports.updateSensorAddress = async function(address, sensorID){
  let pool = await exports.getPool()
  return new Promise(resolve => {
    let query = 'CALL updateSensorAddress(' + address + ', ' + sensorID + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        simpleErrorPrintout("updateSensorAddress() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Updates the passed output in the database with new data.
 * @param {number} id The ID of the output type to update.
 * @param {string} type Output type name.
 * @param {number} pwm 1 for PWM enabled, 0 for not.
 * @param {number} pwm_inversion 1 for inverted PWM, 0 for not. (100% low, vs 
 * 0% low).
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only.
 */
module.exports.updateOutputType = async function(id, type, pwm, pwm_inversion){
  let pool = await exports.getPool()
  return new Promise(resolve => {
    let query = 'CALL updateOutputType(' + id + ', ' + type + ',' + pwm + ',' + pwm_inversion + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        simpleErrorPrintout("updateOutputType() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Updates an output in the database.
 * @param {number} id The ID of the output to update.
 * @param {number} type Output type; must map to an existing output type.
 * @param {string} name Output name.
 * @param {string} description Description of the output. 
 * @param {number} order Ascending logical ordering of the output; higher 
 * number is lower on the list, with 0 being last. Defaults to 0.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only.
 */
module.exports.updateOutput = async function(id, type, name, description, order){
  let pool = await exports.getPool()
  return new Promise(resolve => {
    let query = 'CALL updateOutput(' + id + ', ' + type + ',' + name + ',' + description + ',' + order + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        simpleErrorPrintout("updateOutput() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}

/**
 * Updates a sensor in the database.
 * @param {number} id ID of the sensor to update.
 * @param {string} model Model number or descriptor of sensor (i.e DS18B20,
 *  BME280).
 * @param {string} type Type of sensor; must map to an existing sensorType.
 * @param {string} location Location descriptor of sensor placement; used to
 *  identify individual sensors.
 * @param {string} units Units read by sensor; used for display purposes.
 * @param {number} hardwareID Hardware identifier used to group sensors that share
 * hardware (i.e. BME280). Each piece of hardware should have its own unique
 * hardwareID.
 * @param {string} protocol Sensor protocol for reading data (i.e. ANALOG
 * , I2C, ONEWIRE).
 * @param {string} address Used for sensors that share a common data pin.
 * @returns {Promise<[object]>} A promise that resolves with the results of the query - this is
 * update only.
 */
module.exports.updateSensor = async function(id, model, type, location, units, hardwareID, protocol, address){
  let pool = await exports.getPool()
  return new Promise(resolve => {
    let query = 'CALL updateSensor(' + id + ', ' + model + ',' + type + ',' + location + ',' + units + ',' + hardwareID + ',' + protocol + ',' + address + ')'
    pool.query(query, (error, results, fields) => {
      //Error on problem.
      if(error) {
        simpleErrorPrintout("updateSensor() failed, database error.");          
        reject(error);
      } else {
        resolve(results[0])
      }
    })
  })
}


