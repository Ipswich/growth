const pug = require('pug')
const path = require('path')
const dbcalls = require('./database_calls')
const utils = require('./utils')
const printouts = require('./printouts')
const moment = require('moment')

const CHART_INTERVAL = 24
const INTERVALS = {
    0: {
        interval: 6,
        title: "6 Hours",
        default: false
    },
    1: {
        interval: 12,
        title: "12 Hours",
        default: false
    },
    2: {
        interval: 24,
        title: "1 Day",
        default: true
    },
    3: {
        interval: 48,
        title: "2 Days",
        default: false
    },
    4: {
        interval: 72,
        title: "3 Days",
        default: false
    },
    5: {
        interval: 168,
        title: "1 Week",
        default: false
    },
}
var chartData = {};

// Generates HTML data from Pug templates for both current conditions and schedule.
async function getIndexData(res, req, interval = CHART_INTERVAL) {
    return new Promise(async (resolve, reject) => {
        var web_data = req.app.get('web_data');
        //Redo old pages
        //setup paths
        const schedules = path.join(req.app.get('views'), '/schedules.pug');
        const currentConditions = path.join(req.app.get('views'), '/currentConditions.pug');
        const addEvent = path.join(req.app.get('views'), '/addEvent.pug');
        const manual = path.join(req.app.get('views'), '/manual.pug');
        //Create pug render functions
        var cSchedules = pug.compileFile(schedules);
        var cCurrentConditions = pug.compileFile(currentConditions);
        var cAddEvent = pug.compileFile(addEvent);
        var cManual = pug.compileFile(manual);
        //grab Index Page Data
        try {
            //Get last readings from sensors
            var sensorData = chartData[interval]
            var sensorTypes = {sensorTypes: req.app.get('state').sensorState.getSensorTypes()};
            var scheduleData = {scheduleData: await dbcalls.getEnabledLiveSchedules()};
            //Format trigger Time to be human readable
            for (var key in scheduleData.scheduleData) {
                if (scheduleData.scheduleData[key].eventTriggerTime != null) {
                    scheduleData.scheduleData[key].eventTriggerTime = utils.formatTimeString(scheduleData.scheduleData[key].eventTriggerTime);
                }
            }
            //Get enabled outputs
            var outputs = {outputs: req.app.get('state').outputState.getOutputIndexData()};
            //Get enabled events
            var events = {events: req.app.get('state').events};
            //Get enabled sensors
            var sensors = {sensors: req.app.get('state').sensorState.getSensorIndexData()};
            //Get python scripts
            var python = {python: utils.getScriptFileNames('py')}
            //Create data object for rendering html
            var intervals = {intervals: INTERVALS}
            //Get outputs from state
            let state = {state: req.app.get('state').outputState.data}
            if (res.locals.authenticated || utils.cookieDetector(req)) {
                var authenticated = {authenticated: true}
            } else {
                var authenticated = {authenticated: false}
            }
            var data = Object.assign({}, web_data, sensorTypes, sensorData, scheduleData, outputs, events, sensors, python, intervals, state, authenticated);
            //Render and add to object
            var manualPug = {manual: cManual(data)};
            var addEventPug = {addEvent: cAddEvent(data)};
            var schedulesPug = {schedules: cSchedules(data)};
            var currentConditionsPug = {currentConditions: cCurrentConditions(data)};
            //Create packet, resolve.
            var packet = Object.assign({}, schedulesPug, currentConditionsPug, addEventPug, manualPug, data);
            resolve(packet);
        } catch (e) {
            printouts.simpleErrorPrintout(e)
            //If error, error
            reject(e);
        }

    })
}

module.exports.getIndexData = getIndexData

// Renders the 'schedules.pug' as HTML and returns the data.
async function getSchedulesHTML(res, req) {
    return new Promise(async (resolve, reject) => {
        var web_data = req.app.get('web_data');
        const schedules = path.join(req.app.get('views'), '/schedules.pug');
        var cSchedules = pug.compileFile(schedules);
        try {
            var scheduleData = {scheduleData: await dbcalls.getEnabledLiveSchedules()};
            //Format trigger Time to be human readable
            for (var key in scheduleData.scheduleData) {
                if (scheduleData.scheduleData[key].eventTriggerTime != null) {
                    scheduleData.scheduleData[key].eventTriggerTime = utils.formatTimeString(scheduleData.scheduleData[key].eventTriggerTime);
                }
            }
            if (res.locals.authenticated || utils.cookieDetector(req)) {
                var authenticated = {authenticated: true}
            } else {
                var authenticated = {authenticated: false}
            }
            var data = Object.assign({}, web_data, scheduleData, authenticated);
            var schedulesPug = {schedules: cSchedules(data)};
            resolve(schedulesPug);
        } catch (e) {
            //If error, error
            printouts.simpleErrorPrintout(e)
            reject(e);
        }
    })
}

module.exports.getSchedulesHTML = getSchedulesHTML

// Renders the 'addEvents.pug' as HTML and returns the data.
async function getAddEventHTML(res, req) {
    return new Promise(async (resolve, reject) => {
        var web_data = req.app.get('web_data');
        const addEvent = path.join(req.app.get('views'), '/addEvent.pug');
        var cAddEvent = pug.compileFile(addEvent);
        try {
            //Get enabled outputs
            var outputs = {outputs: req.app.get('state').outputState.getOutputIndexData()};
            //Get enabled events
            var events = {events: req.app.get('state').events};
            //Get enabled sensors
            var sensors = {sensors: req.app.get('state').sensorState.getSensorIndexData()};
            //Get python scripts
            var python = {python: utils.getScriptFileNames('py')}

            if (res.locals.authenticated || utils.cookieDetector(req)) {
                var authenticated = {authenticated: true}
            } else {
                var authenticated = {authenticated: false}
            }
            var data = Object.assign({}, web_data, outputs, events, sensors, python, authenticated);
            var addEventPug = {addEvent: cAddEvent(data)};
            resolve(addEventPug);
        } catch (e) {
            //If error, error
            printouts.simpleErrorPrintout(e)
            reject(e);
        }
    })
}

module.exports.getAddEventHTML = getAddEventHTML

async function getManualHTML(res, req) {
    return new Promise(async (resolve, reject) => {
        var web_data = req.app.get('web_data');
        const manual = path.join(req.app.get('views'), '/manual.pug');
        var cManual = pug.compileFile(manual);
        try {
            //Get outputs from state
            let state = {state: req.app.get('state').outputState.data}
            if (res.locals.authenticated || utils.cookieDetector(req)) {
                var authenticated = {authenticated: true}
            } else {
                var authenticated = {authenticated: false}
            }
            var data = Object.assign({}, web_data, state, authenticated);
            var manualPug = {manual: cManual(data)};
            resolve(manualPug);
        } catch (e) {
            //If error, error
            printouts.simpleErrorPrintout(e)
            reject(e);
        }
    })
}

module.exports.getManualHTML = getManualHTML

// regenerates chart data for use by web data - offloads it so it only happens once every minute rather than each connect.
async function regenerateChartData(log_interval) {
    let total = 0;
    for (let key in INTERVALS) {
        let start = new Date().getTime();
        let interval = INTERVALS[key].interval
        if (chartData[interval] === undefined) {
            chartData[interval] = await initializeChartData(interval)
        } else {
            chartData[interval] = await updateChartData(interval, log_interval)
        }
        let end = new Date().getTime();
        total += end - start;
        console.log(`${interval} hours of data processed in ${end - start} ms`);
    }
    console.log(`Total elapsed time: ${total} ms`)
}

module.exports.regenerateChartData = regenerateChartData

//Generates chart data for a passed interval
async function initializeChartData(interval) {
    return new Promise(async (resolve, reject) => {
        try {
            var sensorData = {sensorData: await dbcalls.getSensorLastReadings()}
            let previousSensorData = await dbcalls.getSensorLastReadingsByHours(interval)
            for (let key in sensorData.sensorData) {
                //Format logtime to be human readable
                sensorData.sensorData[key].logTime = utils.formatDateString(sensorData.sensorData[key].logTime);
            }
            //Format data for charts
            sensorData.last12 = []
            for (let key in previousSensorData) {
                if (sensorData.last12[previousSensorData[key].sensorID] == undefined) {
                    sensorData.last12[previousSensorData[key].sensorID] = []
                }
                let dataPair = {}
                dataPair.x = previousSensorData[key].logTime
                dataPair.y = previousSensorData[key].data
                sensorData.last12[previousSensorData[key].sensorID].push(dataPair)
            }
        } catch (e) {
            printouts.simpleErrorPrintout(e)
            reject(e)
        }
        resolve(sensorData)
    })
}

//Generates chart data for a passed interval
async function updateChartData(interval, log_interval) {
    return new Promise(async (resolve, reject) => {
        try {
            const nowMinusInterval = new moment().subtract(interval, "h")
            var sensorData = {sensorData: await dbcalls.getSensorLastReadings()}
            let previousSensorData = chartData[interval].last12;
            let newSensorData = {};
            for (var key in sensorData.sensorData) {
                //Format new sensor data
                let dataPair = {}
                dataPair.x = sensorData.sensorData[key].logTime
                dataPair.y = sensorData.sensorData[key].data
                newSensorData[sensorData.sensorData[key].sensorID] = dataPair

                //Format logtime to be human readable
                sensorData.sensorData[key].logTime = utils.formatDateString(sensorData.sensorData[key].logTime);
            }

            //clear out oldest data if we have the full span of data, add new data. Key is sensorID
            for (let key in previousSensorData) {
                console.log(`nowMinusInterval: ${nowMinusInterval}`);
                console.log(`Last data in ${key}: ${previousSensorData[key][previousSensorData[key].length - 1].x}`);
                //remove the oldest data if it's beyond the nowMinusInterval
                while (previousSensorData[key][previousSensorData[key].length - 1].x < nowMinusInterval) {
                    console.log("WE SHIFTED!")
                    previousSensorData[key].shift()
                }
                previousSensorData[key].push(newSensorData[key])
            }

            //set return value to updated last data
            sensorData.last12 = previousSensorData
        } catch (e) {
            printouts.simpleErrorPrintout(e)
            reject(e)
        }
        resolve(sensorData)
    })
}