const fs = require('fs');
const readline = require('readline')
const {simpleLogPrintout, simpleErrorPrintout} = require('./printouts')

const CONFIG_LOCATION = './config/config.json'
const DEFAULT_CONFIG_LOCATION = './config/default_config.json'
const BOARD_MAPPINGS_LOCATION = './config/board_mappings.json'
const WEB_DATA_LOCATION = './config/web-data-config.json'
const DEAFULT_WEB_DATA_LOCATION = './config/web-data-config-default.json'

var config = undefined;
// Stubbable, easier to test than mocking require and means no dependencies.
/**
 * Singleton; Reads config from file - if config is undefined, reads it and
 * returns it. Otherwise returns the previously loaded config file.
 * @param {string} config_location File location for the configuration file to load.
 * @returns the JSON version of the passed file.
 */
const getConfig = function(config_location = CONFIG_LOCATION) {
  if (config) return config
  config = JSON.parse(fs.readFileSync(config_location).toString())
  return config
}
module.exports.getConfig = getConfig

var web_data = undefined;
// Stubbable, easier to test than mocking require and means no dependencies.
/**
 * Singleton; Reads web_data from file - if web_data is undefined, reads it and
 * returns it. Otherwise returns the previously loaded web_data file.
 * @param {string} location File location for the file to load.
 * @returns the JSON version of the passed file.
 */
const getWebData = function(location = WEB_DATA_LOCATION) {
  if (web_data) return web_data
  web_data = JSON.parse(fs.readFileSync(location).toString())
  return web_data
}
module.exports.getWebData = getWebData

/**
 * Gets input from the user through stdin, prompting with the passed string.
 * @param {string} query String to prompt the user with. 
 * @returns The response entered by the user.
 */
const getInput = function(query) {
  const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
  });

  return new Promise(resolve => rl.question(query, ans => {
      rl.close();
      resolve(ans);
  }))
}
module.exports.getInput = getInput

/**
 * Returns config.json from the config directory; if not available, it copies it from default_config and returns it.
 * @returns a configuration file.
 */

const initializeConfig = async function() {
  var config;
  return new Promise(async (resolve, reject) => {
    if(fs.existsSync(CONFIG_LOCATION)){
      config = JSON.parse(fs.readFileSync(CONFIG_LOCATION).toString())
      resolve(config)
    } else {
      simpleLogPrintout("[SETUP] Could not locate config.json, copying from default_config.json.");
      try {
        fs.copyFileSync(DEFAULT_CONFIG_LOCATION, CONFIG_LOCATION)
        config = JSON.parse(fs.readFileSync(CONFIG_LOCATION).toString())
        resolve(config)
      } catch(err) {
        simpleErrorPrintout("ERROR: Could not copy config.json from default_config.json.")
        reject(err)
      }
    }
  });    
}
module.exports.initializeConfig = initializeConfig

/**
 * Returns web-data-config.json from the config directory; if not available, 
 * it copies it from web-data-config-default.json and returns it.
 * @returns a web-data configuration file.
 */

const initializeWebData = async function() {
  var web_data;
  return new Promise(async (resolve, reject) => {
    if(fs.existsSync(WEB_DATA_LOCATION)){
      web_data = JSON.parse(fs.readFileSync(WEB_DATA_LOCATION).toString())
      resolve(web_data)
    } else {
      simpleLogPrintout("[SETUP] Could not locate web-data-config.json, copying from web-data-config-default.json.");
      try {
        fs.copyFileSync(DEAFULT_WEB_DATA_LOCATION, WEB_DATA_LOCATION)
        web_data = JSON.parse(fs.readFileSync(WEB_DATA_LOCATION).toString())
        resolve(web_data)
      } catch(err) {
        simpleErrorPrintout("ERROR: Could not copy web-data-config.json from web-data-config-default.json.")
        reject(err)
      }
    }
  });    
}
module.exports.initializeWebData = initializeWebData

/**
 * Gets a list of the boards available, returns them as both an object and a string.
 * @returns An array of board_list_JSON and an output friendly string.
 */ 
const getBoardData = function() {
  let board_list_JSON;
  let board_list = ''
  try {
    board_list_JSON = JSON.parse(fs.readFileSync(BOARD_MAPPINGS_LOCATION).toString())
  } catch (e) {
    simpleErrorPrintout('ERROR: Could not load board mappings.')
    process.exit(-1)
  }
  let i = 1
  for (let e in board_list_JSON){
    board_list = board_list.concat(e)
    if (i != Object.keys(board_list_JSON).length){
      board_list = board_list.concat(", ")
      i++;
    }
  }
  return [board_list_JSON, board_list]
}
module.exports.getBoardData = getBoardData

/**
 * Updates the saved config file with the passed version.
 * @param {JSON Object} config The updated config to write to file
 * @param {boolean} update Whether or not to update the config.
 * @returns True on success, false on failure, and exits process on error
 */
const configUpdate = function(config, update) {
  if (update == true){
    try {      
      fs.writeFileSync(CONFIG_LOCATION, JSON.stringify(config))
      simpleLogPrintout("\n[SETUP] Config has been updated!\n")
      return true
    } catch (e) {
      simpleErrorPrintout('ERROR: Could not update config.')
      process.exit(-1)
    }
  }
  return false
}
module.exports.configUpdate = configUpdate

/**
 * Checks config to see if there's a board listed, prompts user for
 * input and updates config accordingly.
 * @param {JSON Object} config Config file to check.
 * @param {boolean} update Current update status.
 * @returns An array of the possibly changed config file and update;
 *  [config, update]
 */

const boardCheck = async function(config, update){
  if(config.board == 'null'){
    let [ board_list_JSON, board_list ] = exports.getBoardData()
    simpleLogPrintout("[SETUP] No board specified in config. Please enter your arduino model:")
    let board;
    while (!(board in board_list_JSON)){
      simpleLogPrintout("Available: " + board_list);        
      board = await exports.getInput('> ')
    }
    config.board = board
    update = true 
  } 
  return [config, update]
}
module.exports.boardCheck = boardCheck

/**
 * Checks config to see if there's a database password set, prompts user for
 * input and updates config accordingly.
 * @param {JSON Object} config Config file to check.
 * @param {boolean} update Current update status.
 * @returns An array of the possibly changed config file and update;
 *  [config, update]
 */
const databaseCheck = async function(config, update) {
  if (config.database.password == 'null'){
    simpleLogPrintout("\n[SETUP] No database password specified in config. Please enter the database password for growth_admin:")
    config.database.password = await exports.getInput("> ")  
    update = true  
  }
  return [config, update]
}
module.exports.databaseCheck = databaseCheck

/**
 * Checks config to see if there's a javascript web token secret set,
 * prompts user for input and updates config accordingly.
 * @param {JSON Object} config Config file to check.
 * @param {boolean} update Current update status.
 * @returns An array of the possibly changed config file and update;
 *  [config, update]
 */
const jwtCheck = async function(config, update) {
  if (config.jwt_secret == 'null'){
    simpleLogPrintout("\n[SETUP] jwt_secret has not been changed in config. Please enter a string to use for authentication security:")
    config.jwt_secret = await exports.getInput("> ")
    update = true
  }
  return [config, update]
}
module.exports.jwtCheck = jwtCheck

/**
 * Checks config to see if there's info for nodemailer set,
 * prompts user for input and updates config accordingly.
 * @param {JSON Object} config Config file to check.
 * @param {boolean} update Current update status.
 * @returns An array of the possibly changed config file, update, and warnState.
 *  [config, update, warnState]. warnState is used to inform the system whether 
 * or not nodemailer is setup and can be used.
 */
const nodemailerCheck = async function(config, update, warnState) {
  if ((config.nodemailer.service == 'null' || config.nodemailer.auth.user == 'null' || config.nodemailer.auth.pass == 'null') && config.nodemailer_setup_warn == 'true'){
    simpleLogPrintout("\n[SETUP] nodemailer has not been setup in config, 'Warn' will not be sent.")
    let input = await exports.getInput("Would you like to set this up now? (y/N) ")
    if (input == 'y' || input == 'Y'){
      config.nodemailer.service = await exports.getInput("Please input an emailing service (gmail): \n> ")
      config.nodemailer.auth.user = await exports.getInput("Please input the account's email address: \n>  ")
      config.nodemailer.auth.pass = await exports.getInput("Please input the account's password: \n>  ")
      config.nodemailer_setup_warn = false
      update = true
    } else {
      input = await exports.getInput("Would you like to disable 'Warn' setup in the future? (Y/n) ")
      if (input == 'n' || input == 'N'){
        config.nodemailer_setup_warn = true
        update = true
      }
      warnState = false;
    }
  }
  return [config, update, warnState]
}
module.exports.nodemailerCheck = nodemailerCheck

/**
 * Checks config to see if relay toggle prevention is set,
 * prompts user for input and updates config accordingly.
 * @param {JSON Object} config Config file to check.
 * @param {boolean} update Current update status.
 * @returns An array of the possibly changed config file and update;
 *  [config, update]
 */
const relayTogglePreventionCheck = async function(config, update) {
  if (config.relay_toggle_prevention == 'null'){
    simpleLogPrintout("\n[SETUP] Relay toggle prevention has not been changed in config.")
    input = await exports.getInput("Would you like to enable this? (y/N)")
    if (input == 'y' || input == 'Y'){
      config.relay_toggle_prevention = true
    } else {
      config.relay_toggle_prevention = false
    }
    update = true
  }
  return [config, update]
}
module.exports.relayTogglePreventionCheck = relayTogglePreventionCheck

/**
 * Runs config checks (board/database/jwt/nodemailer/relayTogglePrevention)
 * and updates config accordingly. Returns a value that indicates whether 
 * or not NodeMailer can be used.
 * @param {*} config Config file to run checks against. 
 * @returns a boolean that is used to inform the system whether or not 
 * nodemailer is setup and can be used.
 */
const configChecker = async function(config){
  let update = false;
  let warnState = true;
  return new Promise(async (resolve, reject) => {
    try {
      [config, update] = await exports.boardCheck(config, update);
      [config, update] = await exports.databaseCheck(config, update);
      [config, update] = await exports.jwtCheck(config, update);    
      [config, update, warnState] = await exports.nodemailerCheck(config, update, warnState);
      [config, update] = await exports.relayTogglePreventionCheck(config, update);          
      resolve()
    } catch (e) {
      reject(e)
    }
  }).then(() => {
    exports.configUpdate(config, update)
    return warnState   
  }).catch((e) => {
    simpleErrorPrintout("ERROR: Could not update config.")
    if (e instanceof TypeError) {
      simpleErrorPrintout('Config may be corrupted. Please fix or delete, then try again.')
    }
    process.exit(-1)
  })
}
module.exports.configChecker = configChecker