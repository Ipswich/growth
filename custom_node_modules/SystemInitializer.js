const five = require("johnny-five");
const config = require('../config/config.json')
const dbcalls = require('./utility_modules/database_calls.js')
const events = require('events');
const pEventHandler = require('./event_modules/event_handlers/PeriodicEventHandler.js');
const sEventHandler = require('./event_modules/event_handlers/SensorEventHandler.js');
const tEventHandler = require('./event_modules/event_handlers/TimeEventHandler.js');
const sLogger = require('./event_modules/SensorLogger.js');
const utils = require('./utility_modules/Utils.js');

const LOGGING_TIMER = 60 * 1000 // 1 MINUTE
const EVENT_TIMER = 1 * 1000 // 1 SECOND
const BME280_ADDRESS = 0x76; // TRY 0x77 IF BOARD ISN'T FINDING SENSOR
var board;
var DS18B20_Count = 0;
var DS18B20_Pin = -1;
var DS18B20_Array = [];
var relay_control;

module.exports.initialize = async function initialize(state, app) {
  const doneEmitter = new events.EventEmitter();
  
  return new Promise(async (resolve) => {
    // Get DS18B20 count and pin
    for (let i = 0; i < state.sensorState.getSensorState().length; i++) {      
      if (state.sensorState.data[i].sensorModel == "DS18B20") {
        DS18B20_Count++
        DS18B20_Pin = state.sensorState.data[i].sensorPin
      }
    }
    console.log("Initializing board. . .");
    board = new five.Board({
    repl: false,
    // debug: false
    });
    state.board = board;
    resolve(board)
  }).then((board) => {
    //Find and push DS18B20 Address onto Array
    board.once("ready", function() {   
      if (DS18B20_Count != 0) {
        five.Thermometer.Drivers.get(
          this, "DS18B20", {
            pin: DS18B20_Pin
          }).on('initialized', function(addr){
            //If this address exists in database, do not include in list
            let include = true;
            for (i = 0; i < state.sensorState.getSensorState().length; i++) {
              if (state.sensorState.data[i].sensorModel == "DS18B20" && state.sensorState.data[i].sensorAddress == addr) {              
                include = false;
              }
            }
            if (include){
              DS18B20_Array.push(addr)
            }
            DS18B20_Count--
            if (DS18B20_Count == 0 ){            
              doneEmitter.emit('booted')
            }
        })
      }      
      doneEmitter.on('booted', async () => {
        if(DS18B20_Count == 0 ){ 
          console.log("Initializing sensors. . .");
          await initializeSensors(state)
          console.log("Initializing outputs. . ."); 
          await initializeOutputs(state)
          doneEmitter.emit('hardwareInitialized', state)
        }
      })
      doneEmitter.on('hardwareInitialized', async (state) => {
        console.log("Initializing schedule. . .")
        await initializeSchedule(state)
        state.warnState = app.get('warnState')
        app.set('state', state)
        // If relay control exists, turn on relays
        if(relay_control){
          relay_control.high()
        }       
        console.log(". . .Done!");
      })
      doneEmitter.emit('booted')
    })
  });
}

async function initializeOutputs(state) {
  return new Promise((resolve) => {
    //If relay toggle prevention is set in config, create pin with first output pin
    if(config.relay_toggle_prevention){
      let relay_toggle_pin = utils.getBoardMapping().START_OUTPUT_PIN
      relay_control = new five.Pin(relay_toggle_pin)
      //Handle board interrupts (turn off stuff)
      board.on('exit', () => {
        relay_control.low()           
      })
    }
    //Set up outputs and bind to state object.
    for(let i = 0; i < state.outputState.getOutputState().length; i++){
      let outputPin = state.outputState.data[i].outputPin
      var output = new five.Relay({
        pin: outputPin,
        type: "NC"
      })
      state.outputState.data[i].outputObject = output
      if(state.outputState.data[i].outputPWMPin != null){
        let PWMPin = state.outputState.data[i].outputPWMPin
        var PWM = new five.Led(PWMPin);
        state.outputState.data[i].outputPWMObject = PWM
        //Handle board interrupts (turn off stuff)
        board.on('exit', () => {
          output.open()
          PWM.brightness(0)
        })
      } else {
        //Handle board interrupts (turn off stuff)
        board.on('exit', () => {
          output.open()           
        })
      }
      try {
        output.open()
      } catch (e) {
        utils.errorPrintout("Arduino out of pins! Could not attach all outputs, please check your settings.")
      }
    }
    // console.log(state.outputState.data)
    resolve();
  });
}

async function initializeSensors(state) {
  return new Promise((resolve) => {
    //Set up sensors and bind to state object.
    DS18B20_Array = DS18B20_Array.map(e => e.toString())
    //Get max hardwareID
    var hardwareID = Math.max.apply(Math, state.sensorState.data.map(function(o) { return o.sensorHardwareID; }));
    //Loop through hardware IDs
    let counter = 0
    while (hardwareID > counter) {
      counter++
      let i = 0;
      //Loop through sensors to find ones with matching hardwareID
      for(i; i < state.sensorState.getSensorState().length; i++){  
        let currentState = state.sensorState.data[i]     
        let sensor;
        obj = {controller: currentState.sensorModel}
        //If matching hardwareID and protocol is I2C, get model
        if(counter == currentState.sensorHardwareID && currentState.sensorProtocol == 'I2C'){
          if(currentState.sensorModel == "BME280"){
            obj.address = BME280_ADDRESS;
          }
        // Else if the hardware ID is the current ID, get pin   
        } else if(counter == currentState.sensorHardwareID) {
          obj.pin = currentState.sensorPin
        // Otherwise, skip
        } else {
          continue
        }
        // Create sensor based on type
        switch (currentState.sensorType) {
          case 'Temperature':
            // If DS18B20, go through array of addresses
            if(currentState.sensorModel == "DS18B20"){     
              let address = currentState.sensorAddress
              // If address is null, pull from bottom of array and update sensor
              if (address == null) {
                address = DS18B20_Array[0]
                dbcalls.updateSensorAddress(address, currentState.sensorID)                    
              }
              //Remove address from database
              const index = DS18B20_Array.indexOf(address);
              if (index > -1) {
                DS18B20_Array.splice(index, 1);
              }
              obj.pin = DS18B20_Pin
              address = Number(address)
              obj.address = address
              sensor = new five.Thermometer(obj)
            } else {
              //Otherwise normal temperature sensor
              sensor = new five.Thermometer(obj)
            } 
            break;
          case 'Humidity':
            sensor = new five.Hygrometer(obj)
            break;
          case 'Pressure':
            sensor = new five.Barometer(obj)
            break;
          case 'CarbonDioxide':
            sensor = -1;
            break;
          default:
            sensor = -1;
          }
          currentState.sensorObject = sensor;          
        }
      }
    resolve()
  });
}


//Logic for event checking - checks once a minute
//Check once on load, then every minute thereafter.
async function initializeSchedule(state) {
  //Take initial reading to update database
  //Run events when ready, then set Interval.
  state.events = await dbcalls.getEnabledEvents()
  await sLogger.addSensorReadings(state)
  await utils.regenerateChartData()
  await tEventHandler.TimeEventHandler(state);
  await sEventHandler.SensorEventHandler(state);
  await pEventHandler.PeriodicEventHandler(state);
  setInterval(async function() {
    await sLogger.addSensorReadings(state)
    await utils.regenerateChartData()
  }, LOGGING_TIMER);
  setInterval(async function() {
    await utils.scheduleMinder(state)
    await tEventHandler.TimeEventHandler(state);
    await sEventHandler.SensorEventHandler(state);
    await pEventHandler.PeriodicEventHandler(state);
  }, EVENT_TIMER);
}

