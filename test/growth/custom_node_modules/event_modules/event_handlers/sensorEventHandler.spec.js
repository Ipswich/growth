const chai = require('chai');
const sinon = require('sinon');
const expect = chai.expect;
const assert = chai.assert;
const dbcalls = require('../../../../../custom_node_modules/utility_modules/database_calls.js');
const eventTriggers = require('../../../../../custom_node_modules/event_modules/eventTriggers');
const utils = require('../../../../../custom_node_modules/utility_modules/utils.js');
const TriggeredScheduleMinder = require('../../../../../custom_node_modules/event_modules/event_handlers/TriggeredScheduleMinder');

let sensorEventHandler = require('../../../../../custom_node_modules/event_modules/event_handlers/sensorEventHandler');


describe('sensorEventHandler.js tests', function () {
  describe('sensorEventHandler() tests', function() {
    let test_schedule = [
      {
        scheduleID: 1,
        sensorID: 1,
        scheduleComparator: '>',
        sensorValue: 0
      },
    ];
    let dummy_state = {
      sensorState: {
        data: [{
          sensorID: 1,
          sensorLastValue: 0
        }],
        getSensorVal: sinon.stub().resolves({val: 1}),
        getSensorState: sinon.stub().returns([{
            sensorID: 1,
            sensorLastValue: 0,            
          }])
        }
    }
    it('should call triggerEvent once', async function() {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(utils, 'getSchedule').resolves('');
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await sensorEventHandler.sensorEventHandler(dummy_state);
      sinon.assert.calledOnce(triggerEvent_stub);
    });

    it('should error and end early', async function() {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves(undefined);
      sinon.stub(utils, 'getSchedule').resolves(undefined);
      const test_schedule = undefined;
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      sinon.stub(eventTriggers, 'triggerEvent');
      sensorEventHandler.sensorEventHandler({
      }).then(() => {
        assert.fail();
      }).catch((e) => {
        expect(e).to.be.an('error');
      });
    });

    it('should not call triggerEvent (wrong value)', async function() {
      const dummy_state_value = {
        sensorState: {
          data: [{
            sensorID: 1,
            sensorLastValue: 0
          }],
          getSensorVal: async function() {
            return new Promise((resolve, reject) => {
              resolve({val: -1})
            })
          },
          getSensorState: function() {
            return [{
              sensorID: 1,
              sensorLastValue: 0,            
            }]
          }
        }
      }
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(utils, 'getSchedule').resolves('');
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await sensorEventHandler.sensorEventHandler(dummy_state_value);
      sinon.assert.notCalled(triggerEvent_stub);
    });

    it('should not call triggerEvent (called recently)', async function() {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(utils, 'getSchedule').resolves('');
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));   
      const minder_stub = sinon.stub(TriggeredScheduleMinder.prototype, 'includes')
      minder_stub.returns(true)
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await sensorEventHandler.sensorEventHandler(dummy_state);
      sinon.assert.notCalled(triggerEvent_stub);
    });
  });
});