const chai = require('chai');
const sinon = require('sinon');
const expect = chai.expect;
const assert = chai.assert;
const moment = require('moment');
const dbcalls = require('../../../../../custom_node_modules/utility_modules/database_calls.js');
const eventTriggers = require('../../../../../custom_node_modules/event_modules/EventTriggers');
const utils = require('../../../../../custom_node_modules/utility_modules/Utils.js');
const TriggeredScheduleMinder = require('../../../../../custom_node_modules/event_modules/event_handlers/TriggeredScheduleMinder');

let timeEventHandler = require('../../../../../custom_node_modules/event_modules/event_handlers/timeEventHandler');

function resetModules() {
  delete require.cache[require.resolve('../../../../../custom_node_modules/event_modules/event_handlers/timeEventHandler')];
  timeEventHandler = require('../../../../../custom_node_modules/event_modules/event_handlers/timeEventHandler');
}

describe('timeEventHandler.js tests', () => {
  beforeEach(() =>{
    resetModules()
  })
  describe('timeEventHandler() tests', () => {
    it('should call triggerEvent once', async () => {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(eventTriggers, 'getSchedule').resolves('');
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventTriggerTime: new Date('2020-01-01T12:00:00.000Z')
        },
      ];
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await timeEventHandler.timeEventHandler({});
      sinon.assert.calledOnce(triggerEvent_stub);
    });

    it('should error and end early', async () => {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(eventTriggers, 'getSchedule').resolves('');
      const test_schedule = undefined;
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      sinon.stub(eventTriggers, 'triggerEvent');
      timeEventHandler.timeEventHandler({
      }).then(() => {
        assert.fail();
      }).catch((e) => {
        expect(e).to.be.an('error');
      });
    });

    it('should not call triggerEvent (wrong time)', async () => {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(eventTriggers, 'getSchedule').resolves('');
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventTriggerTime: new Date('2020-01-01T12:01:00.000Z')
        },
      ];
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await timeEventHandler.timeEventHandler({});
      sinon.assert.notCalled(triggerEvent_stub);
    });

    it('should not call triggerEvent (called recently)', async () => {
      sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
      sinon.stub(eventTriggers, 'getSchedule').resolves('');
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventTriggerTime: new Date('2020-01-01T12:00:00.000Z')
        },
      ];

      const minder_stub = sinon.stub(TriggeredScheduleMinder.prototype, 'includes')
      minder_stub.returns(true)
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await timeEventHandler.timeEventHandler({});
      sinon.assert.notCalled(triggerEvent_stub);
    });
  });
});