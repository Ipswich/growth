const chai = require('chai');
const sinon = require('sinon');
const expect = chai.expect;
const assert = chai.assert;
const dbcalls = require('../../../../../custom_node_modules/utility_modules/database_calls.js');
const eventTriggers = require('../../../../../custom_node_modules/event_modules/eventTriggers');
const utils = require('../../../../../custom_node_modules/utility_modules/utils.js');
const TriggeredScheduleMinder = require('../../../../../custom_node_modules/event_modules/event_handlers/TriggeredScheduleMinder');

let periodicEventHandler = require('../../../../../custom_node_modules/event_modules/event_handlers/periodicEventHandler');

function resetModules() {
  delete require.cache[require.resolve('../../../../../custom_node_modules/event_modules/event_handlers/periodicEventHandler')];
  periodicEventHandler = require('../../../../../custom_node_modules/event_modules/event_handlers/periodicEventHandler');
}

describe('periodicEventHandler.js tests', () => {
  beforeEach(() =>{
    resetModules()
    sinon.stub(utils, 'getSchedule').resolves('');
    sinon.stub(dbcalls, 'getEnabledEvents').resolves('');
    sinon.stub(dbcalls, 'disableSchedule')
    sinon.stub(dbcalls, 'addNewSchedule')
  })

  describe('periodicEventHandler() tests', () => {
    it('should call triggerEvent twice', async () => {
      const clock = sinon.useFakeTimers()
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventDuration: 1,
          eventTriggerTime: new Date('2020-01-01T12:00:00.000Z')
        },
      ];
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await periodicEventHandler.periodicEventHandler({});
      clock.tick(60000)
      sinon.assert.calledTwice(triggerEvent_stub);
      clock.restore()
    });

    it('should error and end early', async () => {
      const test_schedule = undefined;
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      sinon.stub(eventTriggers, 'triggerEvent');
      periodicEventHandler.periodicEventHandler({
      }).then(() => {
        assert.fail();
      }).catch((e) => {
        expect(e).to.be.an('error');
      });
    });

    it('should not call triggerEvent (wrong time)', async () => {
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventDuration: 1,
          eventTriggerTime: new Date('2020-01-01T12:01:00.000Z')
        },
      ];
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await periodicEventHandler.periodicEventHandler({});
      sinon.assert.notCalled(triggerEvent_stub);
    });

    it('should not call triggerEvent (called recently)', async () => {
      Date.now = sinon.stub().returns(new Date('2020-01-01T12:00:00.000Z'));
      const test_schedule = [
        {
          scheduleID: 1,
          eventTriggerTime: new Date('2020-01-01T12:00:00.000Z')
        },
      ];
      const minder_stub = sinon.stub(TriggeredScheduleMinder.prototype, 'includes')
      minder_stub.returns(true)
      sinon.stub(utils, 'eventTypeMapper').returns(test_schedule);
      const triggerEvent_stub = sinon.stub(eventTriggers, 'triggerEvent');
      await periodicEventHandler.periodicEventHandler({});
      sinon.assert.notCalled(triggerEvent_stub);
    });
  });
});