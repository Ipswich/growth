const chai = require('chai')
const expect = chai.expect;
const assert = chai.assert;
const sinon = require('sinon')

const utils = require('../../../../custom_node_modules/utility_modules/utils')
const jwt = require('jsonwebtoken')
const moment = require('moment')
const dbcalls = require('../../../../custom_node_modules/utility_modules/database_calls')
const eventTriggers = require('../../../../custom_node_modules/event_modules/eventTriggers')
const fs = require('fs')
const config_helper = require('../../../../custom_node_modules/utility_modules/config_helper');

describe('utils.js tests', () => {
  describe('formatTimeString() tests', () => {
    it('should return a human friendly formatted time', () => {
      let test_val = '20:42:00'
      let expected = '8:42 PM'
      assert.equal(expected, utils.formatTimeString(test_val))
    })

    it('should return "Invalid date"', () => {
      let test_val = '25:42:00'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatTimeString(test_val))
    })
  })

  describe('formatDateString() tests', () => {
    it('should return a human friendly formatted date', () => {
      let test_val = '2000-01-01 20:42:24'
      let expected = 'January 1, 8:42 PM'
      assert.equal(expected, utils.formatDateString(test_val))
    })

    it('should return "Invalid date"', () => {
      let test_val = '2021-01-01 25:18:24'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatDateString(test_val))
    })
  })
  
  describe('formatTimeStringForDB() tests', () => {
    it('should return a database friendly formatted time', () => {
      let test_val = '8:42 PM'
      let expected = '20:42:00'
      assert.equal(expected, utils.formatTimeStringForDB(test_val))
    })

    it('should return "Invalid date"', () => {
      let test_val = '80:42 PM'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatTimeStringForDB(test_val))
    })
  })

  describe('formatDateStringForDB() tests', () => {
    it('should return a database friendly formatted date', () => {
      let test_val = "'01/01/2000'"
      let expected = "'2000-01-01'"
      assert.equal(expected, utils.formatDateStringForDB(test_val))
    })

    it('should return "Invalid date"', () => {
      let test_val1 = "'1/01/2000"
      let test_val2 = "'01/1/2000"
      let test_val3 = "'01/01/00"
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatDateStringForDB(test_val1))
      assert.equal(expected, utils.formatDateStringForDB(test_val2))
      assert.equal(expected, utils.formatDateStringForDB(test_val3))
    })
  })

  describe('scheduleMinder() tests', () => {
    it('should call turnOffOutput once, updateScheduleState twice', async () => {
      let dummy_schedules = [
        {outputID: 1}
      ]
      let dummy_outputs = [
        {outputID: 1},
        {outputID: 2, outputController: 'Manual'},
        {outputID: 3, outputController: 'Schedule'}
      ]
      sinon.stub(dbcalls, 'getEnabledLiveSchedules').resolves(dummy_schedules)
      let stub_setOutputScheduleState = sinon.stub()
      let stub_turnOffOutput = sinon.stub(eventTriggers, 'turnOffOutput')
      let stub_getOutputState = sinon.stub().returns(dummy_outputs)
      
      let dummy_state = {
        outputState: {
          getOutputState: stub_getOutputState,
          setOutputScheduleState: stub_setOutputScheduleState
        }
      }

      await utils.scheduleMinder(dummy_state)

      sinon.assert.calledOnce(stub_turnOffOutput)
      sinon.assert.calledTwice(stub_setOutputScheduleState)
    })

  })

  describe('eventTypeMapper() tests', () => {
    it('should return schedules with event names instead of IDs', () => {
      let dummy_events = [
        {eventID: 1, eventName: 'test1'},
        {eventID: 2, eventName: 'test2'},
        {eventID: 3, eventName: 'test3'}
      ]
      let dummy_schedules = [
        {eventID: 1},
        {eventID: 2},
        {eventID: 3},
        {eventID: 4}
      ]
      let expected = [
        {eventID: 'test1'},
        {eventID: 'test2'},
        {eventID: 'test3'},
        {eventID: 4}
      ]
      utils.eventTypeMapper(dummy_events, dummy_schedules)
      assert.deepEqual(dummy_schedules, expected)
    })
  })

  describe('cookieDetector() tests', () => {
    beforeEach(() => {
      sinon.stub(config_helper, 'getConfig').returns({jwt_secret: 'test'})
    })

    it('should return true for valid token', () => {
      let req = {cookies:{token:jwt.sign('data','test')}}
      assert.isTrue(utils.cookieDetector(req))
    })
    it('should return false for invalid token', () => {
      let req = {cookies:{token:jwt.sign('data','test1')}}
      assert.isFalse(utils.cookieDetector(req))
    })
  })

  describe('getScriptFileNames() tests', () => {
    beforeEach(() => {
      sinon.stub(config_helper, 'getConfig').returns('')
      sinon.stub(fs, 'readdirSync').returns(['test_txt.txt', 'test_py.py', 'test_py1.py'])
    })

    it('should return an array containing two .py files', () => {
      let result = utils.getScriptFileNames('py')
      assert.equal(2, result.length)
      assert.deepEqual(['test_py.py', 'test_py1.py'], result)
    })

    it('should return an array containing one .txt file', () => {
      let result = utils.getScriptFileNames('txt')
      assert.equal(1, result.length)
      assert.deepEqual(['test_txt.txt'], result)
    })

    it('should return an empty array', () => {
      let result = utils.getScriptFileNames('test')
      assert.equal(0, result.length)
    })
  })


  describe("getSchedule() tests", () => {
    it('should return only schedules of the passed type', async () => {
      sinon.stub(dbcalls, 'getEnabledLiveSchedules').resolves([
        {scheduleType: "test"},
        {scheduleType: "not_test"},
        {scheduleType: "test"},
      ])
      let result = await utils.getSchedule('test')
      assert.deepEqual(result, [{scheduleType: 'test'}, {scheduleType: 'test'}])
    })
  })
})