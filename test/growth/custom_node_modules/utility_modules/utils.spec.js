const chai = require('chai')
const expect = chai.expect;
const assert = chai.assert;
const sinon = require('sinon')

const utils = require('../../../../custom_node_modules/utility_modules/utils')
const jwt = require('jsonwebtoken')
const moment = require('moment')
const dbcalls = require('../../../../custom_node_modules/utility_modules/database_calls')
const eventTriggers = require('../../../../custom_node_modules/event_modules/eventTriggers')
const fs = require('fs')
const fsPromises = require('fs/promises')
const config_helper = require('../../../../custom_node_modules/utility_modules/config_helper');

describe('utils.js tests', function() {
  describe('formatTimeString() tests', function() {
    it('should return a human friendly formatted time', function() {
      let test_val = '20:42:00'
      let expected = '8:42 PM'
      assert.equal(expected, utils.formatTimeString(test_val))
    })

    it('should return "Invalid date"', function() {
      let test_val = '25:42:00'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatTimeString(test_val))
    })
  })

  describe('formatDateString() tests', function() {
    it('should return a human friendly formatted date', function() {
      let test_val = '2000-01-01 20:42:24'
      let expected = 'January 1, 8:42 PM'
      assert.equal(expected, utils.formatDateString(test_val))
    })

    it('should return "Invalid date"', function() {
      let test_val = '2021-01-01 25:18:24'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatDateString(test_val))
    })
  })
  
  describe('formatTimeStringForDB() tests', function() {
    it('should return a database friendly formatted time', function() {
      let test_val = '8:42 PM'
      let expected = '20:42:00'
      assert.equal(expected, utils.formatTimeStringForDB(test_val))
    })

    it('should return "Invalid date"', function() {
      let test_val = '80:42 PM'
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatTimeStringForDB(test_val))
    })
  })

  describe('formatDateStringForDB() tests', function() {
    it('should return a database friendly formatted date', function() {
      let test_val = "'01/01/2000'"
      let expected = "'2000-01-01'"
      assert.equal(expected, utils.formatDateStringForDB(test_val))
    })

    it('should return "Invalid date"', function() {
      let test_val1 = "'1/01/2000"
      let test_val2 = "'01/1/2000"
      let test_val3 = "'01/01/00"
      let expected = 'Invalid date'
      assert.equal(expected, utils.formatDateStringForDB(test_val1))
      assert.equal(expected, utils.formatDateStringForDB(test_val2))
      assert.equal(expected, utils.formatDateStringForDB(test_val3))
    })
  })

  describe('scheduleMinder() tests', function() {
    it('should call turnOffOutput once, updateScheduleState twice', async function() {
      let dummy_schedules = [
        {outputID: 1}
      ]
      let dummy_outputs = [
        {outputID: 1},
        {outputID: 2, outputController: 'Manual'},
        {outputID: 3, outputController: 'Schedule'}
      ]
      sinon.stub(dbcalls, 'getEnabledLiveSchedules').resolves(dummy_schedules)
      let stub_setOutputScheduleState = sinon.stub()
      let stub_turnOffOutput = sinon.stub(eventTriggers, 'turnOffOutput')
      let stub_getOutputState = sinon.stub().returns(dummy_outputs)
      
      let dummy_state = {
        outputState: {
          getOutputState: stub_getOutputState,
          setOutputScheduleState: stub_setOutputScheduleState
        }
      }

      await utils.scheduleMinder(dummy_state)

      sinon.assert.calledOnce(stub_turnOffOutput)
      sinon.assert.calledTwice(stub_setOutputScheduleState)
    })

  })

  describe('eventTypeMapper() tests', function() {
    it('should return schedules with event names instead of IDs', function() {
      let dummy_events = [
        {eventID: 1, eventName: 'test1'},
        {eventID: 2, eventName: 'test2'},
        {eventID: 3, eventName: 'test3'}
      ]
      let dummy_schedules = [
        {eventID: 1},
        {eventID: 2},
        {eventID: 3},
        {eventID: 4}
      ]
      let expected = [
        {eventID: 'test1'},
        {eventID: 'test2'},
        {eventID: 'test3'},
        {eventID: 4}
      ]
      utils.eventTypeMapper(dummy_events, dummy_schedules)
      assert.deepEqual(dummy_schedules, expected)
    })
  })

  describe('cookieDetector() tests', function() {
    beforeEach(function() {
      sinon.stub(config_helper, 'getConfig').returns({jwt_secret: 'test'})
    })

    it('should return true for valid token', function() {
      let req = {cookies:{token:jwt.sign('data','test')}}
      assert.isTrue(utils.cookieDetector(req))
    })
    it('should return false for invalid token', function() {
      let req = {cookies:{token:jwt.sign('data','test1')}}
      assert.isFalse(utils.cookieDetector(req))
    })
  })

  describe('getScriptFileNames() tests', function() {
    beforeEach(function() {
      sinon.stub(config_helper, 'getConfig').returns('')
      sinon.stub(fs, 'readdirSync').returns(['test_txt.txt', 'test_py.py', 'test_py1.py'])
    })

    it('should return an array containing two .py files', function() {
      let result = utils.getScriptFileNames('py')
      assert.equal(2, result.length)
      assert.deepEqual(['test_py.py', 'test_py1.py'], result)
    })

    it('should return an array containing one .txt file', function() {
      let result = utils.getScriptFileNames('txt')
      assert.equal(1, result.length)
      assert.deepEqual(['test_txt.txt'], result)
    })

    it('should return an empty array', function() {
      let result = utils.getScriptFileNames('test')
      assert.equal(0, result.length)
    })
  })

  describe("getSchedule() tests", function() {
    it('should return only schedules of the passed type', async function() {
      sinon.stub(dbcalls, 'getEnabledLiveSchedules').resolves([
        {scheduleType: "test"},
        {scheduleType: "not_test"},
        {scheduleType: "test"},
      ])
      let result = await utils.getSchedule('test')
      assert.deepEqual(result, [{scheduleType: 'test'}, {scheduleType: 'test'}])
    })
  })

  describe("getLatestFileName() tests", function() {
    it('should return the name of the most recent txt file (ignore recent jpg)', async function() {
      sinon.stub(fsPromises, 'readdir').resolves(['test1.txt', 'test2.txt', 'test3.jpg'])
      let stub_stat = sinon.stub(fsPromises, 'stat')
      stub_stat.onFirstCall().resolves({ctimeMs: 1})
      stub_stat.onSecondCall().resolves({ctimeMs: 0})
      stub_stat.onThirdCall().resolves({ctimeMs: 2})
      assert.equal(await utils.getLatestFileName('txt', '/test'), 'test1.txt')
    })

    it('should throw an error', async function() {
      sinon.stub(fsPromises, 'readdir').resolves([])
      try {
        await utils.getLatestFileName('txt')
        assert.fail()
      } catch (e){
        assert.typeOf(e, 'Error')
      }
    })
  })

  describe('isTimeBetween() tests', function() {
    it('should return true, time is inside start - stop', function() {
      assert.isTrue(utils.isTimeBetween('22:30', '3:00', '23:50'))
      assert.isTrue(utils.isTimeBetween('22:30', '3:00', '1:50'))
    })

    it('should return false, time is outside start - stop', function() {
      assert.isFalse(utils.isTimeBetween('22:30', '3:00', '4:50'))
      assert.isFalse(utils.isTimeBetween('22:30', '3:00', '21:50'))
    })
  })
})