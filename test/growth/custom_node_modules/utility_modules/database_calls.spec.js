const chai = require('chai')
const sinon = require('sinon')
const expect = chai.expect;
const assert = chai.assert;
const mysql = require("mysql")

var dbcalls
function resetModules() {
  delete require.cache[require.resolve('../../../../custom_node_modules/utility_modules/database_calls')];
  dbcalls = require('../../../../custom_node_modules/utility_modules/database_calls');
}

describe('database_calls.js tests', () => {
  describe('getPool() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should create and return a database pool object', async () => {
      expected_keys = [
        '_events',
        '_eventsCount',
        '_maxListeners',
        'config',
        '_acquiringConnections',
        '_allConnections',
        '_freeConnections',
        '_connectionQueue',
        '_closed'
      ]
      let actual = Object.keys(await dbcalls.getPool())
      expect(expected_keys).to.be.deep.equal(actual)
    })
    it('should call createPool() only once, returning the pool from the initial call', async () => {
      let mysql_stub = sinon.stub(mysql, 'createPool').returns("test")
      await dbcalls.getPool()
      assert.deepEqual(await dbcalls.getPool(), "test")
      sinon.assert.calledOnce(mysql_stub)
    })
  })

  describe('testConnectivity() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = { data : 1 }
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.testConnectivity().then((results)=> {
        expect(results).to.be.deep.equal(test_result)
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.testConnectivity().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewEvent() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewEvent().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewEvent().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewOutput() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewOutputType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })
  
  describe('addNewSchedule() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSchedule().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSchedule().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewScheduleType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewScheduleType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewScheduleType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewSensor() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewSensorType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensorType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensorType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewUser() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewUser().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewUser().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addSensorReading() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addSensorReading().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addSensorReading().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableSchedule() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSchedule().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSchedule().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableOutputType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableOutput() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableSensor() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllEvents() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllEvents().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllEvents().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllOutputs() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllOutputTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSchedules() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllScheduleTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllScheduleTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllScheduleTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSensors() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensors().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensors().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSensorTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllUsers() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllUsers().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllUsers().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledEvents() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledEvents().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledEvents().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledLiveSchedules() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledLiveSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledLiveSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOutputs() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOrderedOutputs() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOrderedOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOrderedOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOutputTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSchedules() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledScheduleTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledScheduleTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledScheduleTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensors() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensors().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensors().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensorTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensorTypes() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })
  
  describe('getScheduleByID() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getScheduleByID().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getScheduleByID().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorDataByType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorDataByType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorDataByType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorLastReadings() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadings().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadings().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorLastReadingsByHours() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadingsByHours().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadingsByHours().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getUser() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getUser().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getUser().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('logScheduledEvent() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.logScheduledEvent().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.logScheduledEvent().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateSensorAddress() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensorAddress().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensorAddress().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateOutputType() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateOutput() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateSensor() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })


})