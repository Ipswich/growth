const chai = require('chai')
const sinon = require('sinon')
const expect = chai.expect;
const assert = chai.assert;
const mysql = require("mysql")

let dbcalls
let config_helper
function resetModules() {
  delete require.cache[require.resolve("../../../../custom_node_modules/utility_modules/config_helper")]
  config_helper = require("../../../../custom_node_modules/utility_modules/config_helper")
  delete require.cache[require.resolve('../../../../custom_node_modules/utility_modules/database_calls')];
  dbcalls = require('../../../../custom_node_modules/utility_modules/database_calls');
}

describe('database_calls.js tests', () => {
  describe('getPool() tests', () => {
    beforeEach(() => {
      resetModules()
    })
    it('should create and return a database pool object', () => {
      sinon.stub(config_helper, 'getConfig').returns({database:null})
      let mysql_stub = sinon.stub(mysql, 'createPool').returns('test')
      let res = dbcalls.getPool()
      assert.deepEqual(res, 'test')
      sinon.assert.calledOnce(mysql_stub)
    })
    
    it('should call createPool() only once', () => {
      sinon.stub(config_helper, 'getConfig').returns({database:null})
      let mysql_stub = sinon.stub(mysql, 'createPool').returns('test')
      dbcalls.getPool()
      let res = dbcalls.getPool()
      assert.deepEqual(res, 'test')
      sinon.assert.calledOnce(mysql_stub)
    })
  })

  describe('testConnectivity() tests', () => {
    it('should resolve with results', async () => {
      let test_result = { data : 1 }
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.testConnectivity().then((results)=> {
        expect(results).to.be.deep.equal(test_result)
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.testConnectivity().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewEvent() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewEvent().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewEvent().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewOutput() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewOutputType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })
  
  describe('addNewSchedule() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSchedule().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSchedule().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewScheduleType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewScheduleType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewScheduleType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewSensor() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewSensorType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensorType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewSensorType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addNewUser() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewUser().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addNewUser().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('addSensorReading() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addSensorReading().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.addSensorReading().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableSchedule() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSchedule().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSchedule().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableOutputType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableOutput() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('disableSensor() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.disableSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllEvents() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllEvents().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllEvents().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllOutputs() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllOutputTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllOutputTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSchedules() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllScheduleTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllScheduleTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllScheduleTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSensors() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensors().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensors().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllSensorTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getAllUsers() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllUsers().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getAllUsers().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledEvents() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledEvents().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledEvents().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledLiveSchedules() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledLiveSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledLiveSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOutputs() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOrderedOutputs() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOrderedOutputs().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOrderedOutputs().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledOutputTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledOutputTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSchedules() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSchedules().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSchedules().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledScheduleTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledScheduleTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledScheduleTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensors() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensors().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensors().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensorTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getEnabledSensorTypes() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getEnabledSensorTypes().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })
  
  describe('getScheduleByID() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getScheduleByID().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getScheduleByID().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorDataByType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorDataByType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorDataByType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorLastReadings() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadings().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadings().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getSensorLastReadingsByHours() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadingsByHours().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getSensorLastReadingsByHours().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('getUser() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getUser().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.getUser().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('logScheduledEvent() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.logScheduledEvent().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.logScheduledEvent().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateSensorAddress() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensorAddress().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensorAddress().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateOutputType() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutputType().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutputType().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateOutput() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutput().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateOutput().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })

  describe('updateSensor() tests', () => {
    it('should resolve with results', async () => {
      let test_result = [{ data : 1 }]
      const connStub = { query: sinon.stub().yields(undefined, test_result), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensor().then((results)=> {
        expect(results).to.be.deep.equal(test_result[0])
      }).catch(() => {
        assert.fail()
      })
    })
    it('should reject with error', async () => {         
      const connStub = { query: sinon.stub().yields(new Error("ERROR!")), release: sinon.stub() };            
      sinon.stub(dbcalls, "getPool").resolves(connStub); 
      await dbcalls.updateSensor().then(()=> {
        assert.fail()
      }).catch((error) => {
        expect(error).to.be.an('error')
      })
    })
  })


})