const chai = require('chai');
const sinon = require('sinon');
const readline = require('readline');
const fs = require('fs');
const expect = chai.expect;
const assert = chai.assert;

var config_helper

function resetModules() {
  delete require.cache[require.resolve('../../../../custom_node_modules/utility_modules/config_helper')];
  config_helper = require('../../../../custom_node_modules/utility_modules/config_helper');
}

describe('config_helper.js tests: ', () => {

  describe('getConfig() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    let config_fixture = {"test" : "test"}
    it('should set and return a parsed JSON object', () => {
      sinon.stub(JSON, 'parse').returns(config_fixture)
      assert.deepEqual(config_helper.getConfig(), config_fixture)
    })
    it('should call JSON.parse() only once, returning the config from the initial call', () => {
      let JSON_stub = sinon.stub(JSON, 'parse').returns(config_fixture)
      config_helper.getConfig()
      assert.deepEqual(config_helper.getConfig(), config_fixture)
      sinon.assert.calledOnce(JSON_stub)
    })
  })

  describe('getWebData() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    let config_fixture = {"test" : "test"}
    it('should set and return a parsed JSON object', () => {
      sinon.stub(JSON, 'parse').returns(config_fixture)
      assert.deepEqual(config_helper.getWebData(), config_fixture)
    })
    it('should call JSON.parse() only once, returning the config from the initial call', () => {
      let JSON_stub = sinon.stub(JSON, 'parse').returns(config_fixture)
      config_helper.getWebData()
      assert.deepEqual(config_helper.getWebData(), config_fixture)
      sinon.assert.calledOnce(JSON_stub)
    })
  })


  describe('getInput() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should print query', async () => {
      const readlineInterfaceStub = {
        question: sinon.stub().callsFake((query, callback) => {
          callback('input');
        }),
        close: sinon.stub(),
      };
      sinon.stub(readline, 'createInterface').returns(readlineInterfaceStub);
      await config_helper.getInput('QUERY!')
      sinon.assert.calledWithExactly(readlineInterfaceStub.question, 'QUERY!', sinon.match.func);
      sinon.assert.calledOnce(readlineInterfaceStub.close);    
    })

    it('should return input', async () => {
      const readlineInterfaceStub = {
        question: sinon.stub().callsFake((query, callback) => {
          callback('input');
        }),
        close: sinon.stub(),
      };
      sinon.stub(readline, 'createInterface').returns(readlineInterfaceStub);
      const actual = await config_helper.getInput()
      expect(actual).to.be.eql('input')
      sinon.assert.calledOnce(readlineInterfaceStub.close);
    });
  });

  describe('initializeConfig() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should resolve with the system config', async () => {
      const expected_string = '{"data" : "data"}'
      const expected_object = JSON.parse(expected_string).toString()
      sinon.stub(fs, 'existsSync').returns(true)
      sinon.stub(fs, 'readFileSync').callsFake(() => expected_string)
      let actual = await config_helper.initializeConfig()
      assert.equal(actual, expected_object)
    })
    it('should copy the default config and resolve with it', async () => {
      const expected_string = '{"data" : "data"}'
      const expected_object = JSON.parse(expected_string).toString()
      sinon.stub(fs, 'existsSync').returns(false)
      sinon.stub(fs, 'copyFileSync').returns(undefined)
      sinon.stub(fs, 'readFileSync').returns(expected_string)
      let actual = await config_helper.initializeConfig()
      assert.equal(actual, expected_object)
    })
    it('should reject promise on failed config copy', async () => {
      sinon.stub(fs, 'existsSync').returns(false)
      sinon.stub(fs, 'copyFileSync').throws(new Error("ERROR!"))
      await config_helper.initializeConfig().then(
        () => Promise.reject(new Error('Expected method to reject.')),
        err => assert.instanceOf(err, Error)
      );
    })
  })
  
  describe('initalizeWebData() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should resolve with the system config', async () => {
      const expected_string = '{"data" : "data"}'
      const expected_object = JSON.parse(expected_string).toString()
      sinon.stub(fs, 'existsSync').returns(true)
      sinon.stub(fs, 'readFileSync').callsFake(() => expected_string)
      let actual = await config_helper.initializeWebData()
      assert.equal(actual, expected_object)
    })
    it('should copy the default config and resolve with it', async () => {
      const expected_string = '{"data" : "data"}'
      const expected_object = JSON.parse(expected_string).toString()
      sinon.stub(fs, 'existsSync').returns(false)
      sinon.stub(fs, 'copyFileSync').returns(undefined)
      sinon.stub(fs, 'readFileSync').returns(expected_string)
      let actual = await config_helper.initializeWebData()
      assert.equal(actual, expected_object)
    })
    it('should reject promise on failed config copy', async () => {
      sinon.stub(fs, 'existsSync').returns(false)
      sinon.stub(fs, 'copyFileSync').throws(new Error("ERROR!"))
      await config_helper.initializeWebData().then(
        () => Promise.reject(new Error('Expected method to reject.')),
        err => assert.instanceOf(err, Error)
      );
    })
  })

  describe('getBoardData() tests', () => {
    it('should return an array of board data', () => {
      let stub_return = '{"test1" : "test1", "test2" : "test2"}'
      let expected = [JSON.parse(stub_return), 'test1, test2']
      sinon.stub(fs, 'readFileSync').returns(stub_return)
      let result = config_helper.getBoardData()
      assert.hasAllKeys(expected[0], result[0])
      assert.equal(expected[1], result[1])
    })
    it('should error and exit', () => {
      sinon.stub(fs, 'readFileSync').throws(new Error("ERROR!"))
      sinon.stub(process, 'exit').callsFake()
      config_helper.getBoardData()
      sinon.assert.calledOnce(process.exit)
    })
  })

  describe('boardCheck() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should return an array of a board object and "true"', async () => {
      let getBoardData_return = [ { test1: 'test1', test2: 'test2' }, 'test1, test2' ]
      sinon.stub(config_helper, 'getInput').resolves("test1")
      sinon.stub(config_helper, 'getBoardData').returns(getBoardData_return)
      let actual = await config_helper.boardCheck({'board' : 'null'}, false)
      expect(actual[0]).to.be.eql({ board: 'test1' })
      expect(actual[1]).to.be.true
    })
    it('should return the passed object and "true"', async () => {
      let expected = { board: 'test1' }
      let actual = await config_helper.boardCheck(expected, true)
      expect(actual[0]).to.be.eql(expected)
      expect(actual[1]).to.be.true
    })
  })

  describe('databaseCheck() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should return an array of a database object and "true"', async () => {
      let test_config = { database: { password: 'null' } }
      let expected = { database: { password: 'test1' } }
      sinon.stub(config_helper, 'getInput').resolves("test1")
      let actual = await config_helper.databaseCheck(test_config, false)
      expect(actual[0]).to.be.eql(expected)
      expect(actual[1]).to.be.true

    })
    it('should return the passed object and "true"', async () => {
      let expected = { database: { password: 'test1' } }
      let actual = await config_helper.databaseCheck(expected, true)
      expect(actual[0]).to.be.eql(expected)
      expect(actual[1]).to.be.true
    })
  })

  describe('jwtCheck() tests', () => {
    it('should return an array of a jwt_secret object and "true"', async () => {
      let test_config = { jwt_secret: 'null' }
      let expected = { jwt_secret: 'test1' }
      sinon.stub(config_helper, 'getInput').resolves("test1")
      let actual = await config_helper.jwtCheck(test_config, false)
      expect(actual[0]).to.be.eql(expected)
      expect(actual[1]).to.be.true

    })
    it('should return the passed object and "true"', async () => {
      let expected = { jwt_secret: 'test1' }
      let actual = await config_helper.jwtCheck(expected, true)
      expect(actual[0]).to.be.eql(expected)
      expect(actual[1]).to.be.true
    })
  })

  describe('nodeMailerCheck() tests', () => {
    beforeEach(() => {
      resetModules();
    });  
    it('should return a filled array of nodeMailer object, "true", and "true"', async () => {
      let test_config = {
        nodemailer: {
          auth: { user: 'null', pass: 'null' },
          service: 'null',
        },
        nodemailer_setup_warn : 'true'
      }
      let expected = {
        nodemailer: {
          auth: { user: 'test@example.com', pass: 'password' },
          service: 'gmail',
        },
        nodemailer_setup_warn : false
      }
      getInput_fn = sinon.stub(config_helper, 'getInput').onCall(0).resolves('y')
      getInput_fn.onCall(1).resolves('gmail')
      getInput_fn.onCall(2).resolves('test@example.com')
      getInput_fn.onCall(3).resolves('password')
      let actual = await config_helper.nodemailerCheck(test_config, false, true)
      expect(actual[0]).to.be.deep.equal(expected)
      expect(actual[1]).to.be.true
      expect(actual[2]).to.be.true


    })
    it('should return an array of the passed object, "true", and "false"', async () => {
      let test_config = {
        nodemailer: {
          auth: { user: 'null', pass: 'null' },
          service: 'null'
        },
        nodemailer_setup_warn : 'true'
      }
      let getInput_fn = sinon.stub(config_helper, 'getInput').onCall(0).resolves('')
      getInput_fn.onCall(1).resolves('n')
      
      let actual = await config_helper.nodemailerCheck(test_config, false, true)
      test_config.nodemailer_setup_warn = true 
      expect(actual[0]).to.be.deep.equal(test_config)
      expect(actual[1]).to.be.true
      expect(actual[2]).to.be.false
    })
    it('should return an array of the passed object, "false", and "false"', async () => {
      let test_config = {
        nodemailer: {
          auth: { user: 'null', pass: 'null' },
          service: 'null'
        },
        nodemailer_setup_warn : 'true'
      }
      sinon.stub(config_helper, 'getInput').resolves('')
      
      let actual = await config_helper.nodemailerCheck(test_config, false, true)
      test_config.nodemailer_setup_warn = true   
      expect(actual[0]).to.be.deep.equal(test_config)
      expect(actual[1]).to.be.false
      expect(actual[2]).to.be.false
    })
    it('should return an array of the passed object, "false", and "true"', async () => {
      let test_config = {
        nodemailer: {
          auth: { user: 'test', pass: 'test' },
          service: 'test'
        },
        nodemailer_setup_warn : 'true'
      }
      
      let actual = await config_helper.nodemailerCheck(test_config, false, true)
      test_config.nodemailer_setup_warn = false   
      expect(actual[0]).to.be.deep.equal(test_config)
      expect(actual[1]).to.be.false
      expect(actual[2]).to.be.true
    })
  })

  describe('relayTogglePreventionCheck() tests', () => {
    beforeEach(() => {
      resetModules();
    });
    it('should return an array of an object with true, and "true"', async () => {
      let test_config = {
        relay_toggle_prevention : 'null'
      }
      sinon.stub(config_helper, 'getInput').resolves('y')
      let actual = await config_helper.relayTogglePreventionCheck(test_config, false)
      expect(actual[0].relay_toggle_prevention).to.be.true
      expect(actual[1]).to.be.true
    })
    it('should return an array of an object with false, and "true"', async () => {
      let test_config = {
        relay_toggle_prevention : 'null'
      }
      sinon.stub(config_helper, 'getInput').resolves('n')
      let actual = await config_helper.relayTogglePreventionCheck(test_config, false)
      expect(actual[0].relay_toggle_prevention).to.be.false
      expect(actual[1]).to.be.true
    })
    it('should return an array of the passed object with "test", and "false"', async () => {
      let test_config = {
        relay_toggle_prevention : 'test'
      }
      let actual = await config_helper.relayTogglePreventionCheck(test_config, false)
      expect(actual[0].relay_toggle_prevention).to.be.deep.equal('test')
      expect(actual[1]).to.be.false
    })
  })

  describe('configUpdate() tests', () => {
    it('should update config', () => {
      let config = {}
      sinon.stub(fs, 'writeFileSync').callsFake()
      config_helper.configUpdate(config, true)    
      sinon.assert.calledOnce(fs.writeFileSync)
    })
    it('should not update config', () => {
      let config = {}
      let fs_spy = sinon.spy(fs, 'writeFileSync')
      let process_spy = sinon.spy(process, 'exit')
      config_helper.configUpdate(config, false)
      assert.isTrue(fs_spy.notCalled)
      assert.isTrue(process_spy.notCalled)
    })
    it('should error and exit', () => {
      let config = {}
      sinon.stub(fs, 'writeFileSync').throws(new Error('ERROR!'))
      sinon.stub(process, 'exit').callsFake()
      config_helper.configUpdate(config, true)
      sinon.assert.calledOnce(process.exit)
    })
  })

  describe('configChecker() tests', () => {
    it('should return true', async () => {
      let test_config = {}
      sinon.stub(config_helper, 'boardCheck').resolves([test_config, true])
      sinon.stub(config_helper, 'databaseCheck').resolves([test_config, true])
      sinon.stub(config_helper, 'jwtCheck').resolves([test_config, true])
      sinon.stub(config_helper, 'nodemailerCheck').resolves([test_config, true, false])
      sinon.stub(config_helper, 'relayTogglePreventionCheck').resolves([test_config, true])
      sinon.stub(config_helper, 'configUpdate').resolves([test_config, true])
      let actual = await config_helper.configChecker(test_config, true)
      expect(actual).to.be.false
    })
    it('should call error and exit', async () => {
      let test_config = {}
      sinon.stub(config_helper, 'boardCheck').throws(new Error("ERROR!"))
      sinon.stub(process, 'exit').callsFake()
      await config_helper.configChecker(test_config, true)    
      sinon.assert.calledOnce(process.exit)
    })
  })
})